# 학습 레포트 41일차 2021-03-01 (월)

## 1. 학습 날짜
> ### 2021-03-01 (월)

## 2. 학습 시간
> ### 10:00 ~ 11:30 (집)
> ### 12:30 ~ 13:30 (집)
> ### 16:30 ~ 18:30 (집)

## 3. 학습 범위 및 주제
### | cub3D 과제 |

## 4. 동료 학습 방법
- 해당 없음

## 5. 학습 목표
- cub3D 맛보기
- mlx 함수 사용해보기

## 6. 상세 학습 내용
- **실제 코딩 시간** 5시간
- **참고한 내용** [ray caster youtube](https://www.youtube.com/watch?v=gYRrGTC7GtA&ab_channel=3DSage), [taelee 님 mlx_example](https://github.com/taelee42/mlx_example), [365kim 님 raycasting_tutorial](https://github.com/365kim/raycasting_tutorial)

### mlx 연습
cub3D 과제를 진행할 때 사용하는 라이브러리로 mlx 가 주어진다. mlx에 대해 알아보니 openGL 라이브러리를 과제 진행에 도움이 되도록 정리된 모음이라는 느낌이 들었다. taelee 님 께서 mlx 함수 연습 예제들을 만들어 주셔서 깃헙을 참고해 연습을 해보았다.

### mlx_new_window
mlx의 함수들을 사용해서 cub3D 과제를 진행하기위한 기초 다질 필요가 있다. mlx_new_window 함수를 사용하면 새로운 창을 띄울 수 있다. 해당 창은 gui로 작업되는 것 같다.

```c
#include "mlx.h"

int main()
{
    void *mlx_ptr;
    void *win_ptr;
    
    mlx_ptr = mlx_init();
    win_ptr = mlx_new_window(mlx_ptr, 500, 500, "mlx_window");
    mlx_loop(mlx_ptr);
}
```
1. mlx 함수들을 사용하기 위해 `mlx.h`를 추가한다.
2. mlx 초기화를 해주는 `mlx_init()` 함수를 사용해 mlx_ptr 을 초기화해준다.
3. 새로운 창을 띄우기 위해 `mlx_new_window` 함수를 사용한다.
4. 만들어진 창을 유지 하기위한 `mlx_loop`를 사용해 준다.

위 코드를 실행하면 검은 배경의 새로운 창이 하나 뜨게 된다. 물론 터미널은 유지 된 채로 생성된다.

### mlx_pixel_put
mlx_pixel_put 함수는 그래픽 창에 픽셀을 그릴 수 있다. 색깔은 rgb 값으로 mlx_rgb.c 에 자세히 나열되어 있다. mlx_image 함수들을 적절히 사용해 다양한 이미지나 도트를 찍어 볼 수 있었다.

```c
...
mlx_pixel_put(mlx_ptr, win_ptr, 50, 50, 0xffffff);
...
```
함수의 세 번째, 네 번째 인자는 좌표로 (50, 50)에 0xffffff 값을 가지는 흰색으로 표시하는 것이다.

### mlx_hook
mlx_hook 함수는 키보드, 마우스, 창닫기 버튼 등 입력을 받을 수 있다고 한다.\
```c
...
mlx_hook(win_ptr, event, 0, &key_press, &param);
...
```
event 는 key_press, key_release, mouse, exit 등 정보를 가지는 것 같다.\
&key_press 는 함수포인터를 넘겨주며 다음에 오는 &param 인자를 데이터로 사용하는 것 같다.

### 연습 프로그램 - 직선 그리기
```c
#include "mlx.h"

#define X_EVENT_KEY_PRESS 2

#define KEY_SPACE 49
#define KEY_ESC   53
#define KEY_W     13
#define KEY_A     0
#define KEY_S     1
#define KEY_D     2
#define KEY_C     8

typedef struct s_xy
{
    double x1;
    double y1;
    double x2;
    double y2;
} t_xy

typedef struct s_param
{
    int x;
    int y;
    void *mlx_ptr;
    void *win_ptr;
    t_xy xy;
} t_param
```
1. X_EVENT_KEY_PRESS 는 mlx_hool 함수에서 사용하기위한 이벤트 값이다.
2. KEY_SPACE 부터 KEY_C 까지는 키보드의 각 키에 대한 값이다.
3. s_xy 구조체는 직선을 그리기 위한 (x1, y1), (x2, y2) 좌표 값을 저장하기위한 구조체 이다.
4. s_param 구조체는 처음 생성하고 유지되는 정보를 가지는 구조체이다. x, y는 시작 좌표이다.

```c
void param_init(t_param *param)
{
    param->x = 50;
    param->y = 50;
    param->mlx_ptr = mlx_init();
    param->win_ptr = mlx_new_window(param->mlx_ptr, 500, 500, "mlx_key");
    
    param->xy.x1 = 0;
    param->xy.y1 = 0;
    param->xy.x2 = 0;
    param->xy.y2 = 0;
}
```
1. param_init 함수는 프로그램 실행시 값들을 초기화 하고 새로운 창을 생성한다.

```c
int key_press(int keycode, t_param *param)
{
    static int space_count;
    
    if (keycode == KEY_W)
        param->y -= 5;
    else if (keycode == KEY_S)
        param->y += 5;
    else if (keycode == KEY_A)
        param->x -= 5;
    else if (keycode == KEY_D)
        param->x += 5;
    else if (keycode == KEY_SPACE)
    {
        if (space_count == 0)
        {
            param->xy.x1 = param->x;
            param->xy.y1 = param->y;
            space_count = 1;
        }
        else
        {
            param->xy.x2 = param->x;
            param->xy.y2 = param->y;
            space_count = 2;
        }
    }
    else if (keycode == KEY_ESC)
        exit(0);
    else if (keycode == KEY_C)
        mlx_clear_window(param->mlx_ptr, param->win_ptr);
    if (space_count == 2)
    {
        DDA(param);
        space_count = 0;
    }
    mlx_pixel_put(param->mlx_ptr, param->win_ptr, param->x, param->y, 0xffffff);
    return (0);
}
```

## 7. 학습 내용에 대한 개인적인 총평

## 8. 다음 학습 계획