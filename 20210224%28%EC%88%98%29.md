# 학습 레포트 n일차 2021-02-24(수)
## 1.
## 2.
## 3.
## 4.
## 5.
## 6.상세 학습 내용
- **실제 코딩 시간** 1시간
- **참고한 내용**

### printf 너비, 정밀도 값에 대해서
ft_printf 동료평가를 받으면서 `seongcho` 님 께서 만약 너비값 또는 정밀도 값이 `INT_MAX` 값 `2147483647을 넘어가게 되면 어떻게 작동하는지에 대해서 질문을 주셨다.\
내가 작성한 코드는 너비와 정밀도 값을 `size_t` 형으로 받기 때문에 `INT_MAX`를 넘는 값도 저장하고 너비를 처리해 결과 값을 만들고 출력을 하게 된다. 하지만 실제 `printf` 함수는 `-1`을 반환하고 아무런 출력도 하지 않는다는 것을 알려주셨다.\
평가 항목에는 없는 사항이지만 printf를 최대한 비슷하게 만드는 것이 목적이고 정의되지 않은 경고가 뜨지 않는 선에서는 가능하면 실제 printf 함수와 작동이 동일하게 되어야 한다고 생각했다. 평가는 잘 마쳤지만 평가를 끝낸 후 이것에 대해 고민 해 보고, ft_printf 함수에 처음 들어온 format을 탐색하고 처리할 수 있도록 함수를 하나 더 만들었다.

### ft_check_format
`ft_check_format` 함수는 실제로 문자열을 처리하고 출력하기 전에 먼저 format과 가변인자를 받아 너비와 정밀도 값이 `INT_MAX` 보다 크거나 같은지를 체크하는 함수이다.

```c
int ft_check_format(va_list cp, char *str, size_t *signal)
{
    char *type_str;
    int  i;
    
    i = 0;
    type_str = NULL;
    while (str[i] != '\0')
    {
        if (str[i] == '%')
        {
            type_str = ft_substr(&(str[i]), 0, ft_check_type(&(str[i])) + 1);
            ft_init_signal(type_str, cp, signal);
            if ((i + signal[3] >= 2147483647 || signal[8] >= 2147483647)
                return (0);
        }
        i++;
    }
    return (1);
}

```

## 7.
## 8.