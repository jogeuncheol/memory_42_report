# 학습 레포트 8일차 2021-01-06(수)
## 1.학습 날짜
> ### 2021-01-06(수)
## 2.학습 시간
> ### 00:00 ~ 05:00 (집)
> ### 17:00 ~ 20:00 (집)
## 3.학습 범위 및 주제
### | file discriptor, open 함수, read 함수에 대해서 알아보기 | get next line 함수 작성 하기 |
## 4.동료 학습 방법
- 온라인 - 슬랙 검색!!
## 5.학습 목표
- get next line 과제를 풀기위한 open 함수와 file descriptor, read 함수 테스트
## 6.상세 학습 내용
- **코딩에 사용된 시간** 약 8시간
- **참고한 내용** [스택 오버플로우](https://blog.naver.com/sosa654/221691037042), 인트라 사이트 c 영상 파일 입출력 파트.

### file descriptor
파일 기술자는 운영체제에서 파일을 사용할 때 각 파일에 대한 정보를 유지하는 기억장치의 한 영역이 또는 그 정보라고 한다.\
`open` 함수를 통해 파일을 읽어오면 해당 파일에 인덱스를 저장해 두고 사용자가 원하는 파일을 읽을 수 있도록 도와준다. 인덱스는 0 부터 시작되며 0, 1, 2는 예약된 인덱스로 0은 표준 입력, 1은 표준 출력, 2는 표준 에러를 뜻한다.\
파일로부터 받아오게되면 인덱스는 3부터 시작되며, 해당 파일은 `close` 함수를 사용해 닫을 수 있다.

### open 함수
- **형식** `int open(char *path, int flags[, mode_t perm])`
- **반환 값** `int` 형
- **설명**\
`path`에 해당하는곳으로 부터 파일을 연다.
open 함수로부터 파일을 읽을 수 있고, 키보드로 입력을 받아 처리할 수 있다. 그리고 출력 재지정으로 해당 프로그램에 입력으로 줄 수 있다.\
두번째 flags는 시작모드로 읽기전용, 쓰기전용, 읽기쓰기 가능으로 파일을 열 수 있다. 또한 파일이 없다면 파일을 만드는 CREATE, 유저에게 권한을 추가할 수 있는 IRUSR, IWUSR 등 플래그가 붙을 수 있다.\
읽기 전용 = O_RDONLY, 쓰기 전용 = O_WRONLY, 읽기쓰기 = O_RDWR\
파일 열기에 실패하면 -1을, 성공하면 해당 file descriptor의 인덱스를 반환한다.

### read 함수
- **형식** `int read(int fd, char *buf, int count)`
- **반환 값** `int` 형
- **설명**\
`read` 함수는 `open`한 파일로 부터 `count` byte 만큼 읽는다.\
`fd`는 파일디스크립터로 `open` 한 파일의 인덱스이다.\
`buf`는 출력 버퍼로 `fd`에서 읽은 데이터가 저장된다.\
`count`는 읽는데 필요한 바이트 수로 `buf`에 저장되는 바이트 수 이다.
`read` 함수의 반환값은 `int`형 데이터로 `buf`에 저장된 길이와 같다.
만약 파일의 끝을 읽으면 `read` 함수는 0을 반환한다.

### 새롭게 알게된 내용들 정리
### open의 반환값 fd 와 read의 인자 fd
get next line 과제를 진행하기 위해 파일 입출력에 대해 공부를 진행하였다.\
`open` 함수로 파일 a.txt을 읽었다고 했을 때, fd = 3으로 저장이 되었고, 충분히 큰 버퍼크기로 `read`를 하면 read의 반환값은 a.txt의 전체 바이트 수가 되었다. 그리고 다시한번 `read` 함수를 불러오면 이미 a.txt의 파일 끝까지 읽었기 때문에 더이상 파일을 읽지 않고 0을 반환한다.\
이는 함수로 만들어 `open`한 파일의 fd를 인자로 넘겨주어도 동일하게 작동을 하였다.\
get next line은 open이후 get_next_line 함수를 작성해 fd를 인자로 넘겨주게 되어있고, get_next_line 함수 안에서 최소한의 버퍼로 fd에 해당하는 파일을 `read`함수로 읽어 `\n`을 찾아 한 줄씩 반환해야 한다.\

**fd**가 단순히 파일을 정상적으로 열였을 때 알려주기 위한 반환값이라고 생각했었는데, 사실은 `open`한 파일에 대한 인덱스로써 `fd`를 이용해 해당 파일에 접근 가능하게 해준다고 이해하였다.\

### get_next_line 함수 구조.
get_next_line 함수는 `open`한 fd를 한줄씩 읽어 `line`에 저장하고 1, 0, -1을 반환하는 함수이다. get_next_line 함수는 호출하는 위치에서 함수를 반복문에서 호출한다고 subject에 기입되어 함수안에서 read를 한번 하도록 하였다.\
```c
if ((read_fd = read(fd, str, BUFFER_SIZE)) > 0)
```
그리고 읽은 내용은 `str`에 저장되고 읽은 내용에 `\n` 이 없다면 다시 읽도록 해야했다. 따라서 get_next_line을 다시 호출하도록 하였다.\
```c
return (get_next_line(fd, line))
```
함수를 다시 호출 했을 때 읽은 버퍼의 값이 사라지지 않도록 `static` 변수를 만들어 읽은 값을 저장하도록 하였다.
```c
static char mk_str[];
```

**새롭게 알게된 내용**
- `static`변수에 대해서.
static 변수는 메모리의 데이터영역에 저장된다고 한다. 메모리의 구조는 코드영역, 데이터영역, 힙영역, 스택영역, 커널영역으로 나눠지는데 static 변수는 데이터 영역에 저장된다고 한다. 데이터영역 에는 정적변수와 함께 전역변수가 저장되고, 해당 변수의 값은 프로그램이 종료될때까지 유지된다.\
스택영역은 함수범위에서 생성되고 소멸하는 변수로 평소에 사용하는 변수가 되고, 힙 영역은 동적할당으로 사용된다.\
스택 영역은 시스템에서 제한적인 크기를 가진다고 한다. 유닉스의 기본 스택 사이즈는 8MB 라고 한다. 만약 스택영역으로 선언한 변수 c의 크기가 8MB보다 크면 스택 오버플로우가 발생한다.\
따라서 해당 변수를 전역 변수 또는 정적변수 또는 동적할당을 하여 힙 영역에 저장하여 사용하면 문제를 해결할 수 있다.

이어서 get_next_line 함수의 구조를 보면, 재 호출 된 get_next_line 함수는 다시 `read`함수로 파일의 다음 내용을 읽고 복사된 내용에서 `\n`을 찾는다. 만약 `\n`이 있다면 `add_str` 함수를 호출하도록 하였다.\
```c
int add_str(char *mk_str, char **line)
{
    while (mk_str[i] != '\n')
        i++;
    mk_str[i] = '\0';
    *line = ft_strdup(mk_str);
    ft_strlcpy(mk_str, &mk_str[i + 1], ft_strlen(&mk_str[i + 1]) + 1);
    return (1);
}
```
add_str 함수는 저장된 문자열에서 `\n`문자를 찾고 그 위치를 '\0'문자로 바꿔 strdup 함수로 line에 동적할당으로 값을 복사한 후 '\n' 이후 남은 문자를 저장하는 구조이다.\
'\n' 이후 값을 저장하는 이유는 다음에 파일에서 `read`할 때 이전 내용을 잃어버리지 않게 하기 위함이다.

만약 파일을 전부 읽었다면 read 함수의 반환값이 0이 되어 make_return 함수를 호출하도록 하였다.
```c
int make_return(int read_fd, char *mk_str, char **line)
{
    if (*mk_str && read_fd == 0)
    {
        *line = ft_strdup(mk_str);
        return (0);
    }
    if (read_fd == 0)
    {
        *line = ft_strdup("");
        return (0);
    }
    if (read_fd < 0)
        return (-1);
    return (0);
}
```
`make_return` 함수는 read_fd의 값이 0일때 즉, 파일을 끝까지 읽어 더이상 읽을것이 없을때 또는 읽기 오류가 발생했을때만 호출이 된다. 만약 파일에 더이상 읽을것이 없는데 읽었던 값이 남아있다면 그때 값을 전부 동적할당으로 복사하고 0을 반환하도록 작성하였다.

## 7.학습 내용에 대한 개인적인 총평
get_next_line 함수를 작성하기 전 open, read, file descriptor에 대해서 알아보았는데 open 함수의 반환값인 fd를 가지고 어떻게 read를 하고, write를 할 수 있는지 piscine 과정중에는 알지 못하였는데 이번에 확실히 알고 넘어갈 수 있게되어 기뻤다.\
아직 과제를 끝내진 못했지만 get_next_line 함수를 작성하면서 파일에서 읽는 순서와 읽기전 남아있는 데이터를 처리하는 방법등 생각할 거리가 많다고 느껴졌고 쉽다면 쉽고 어렵다면 어려운 과제가 될것같다고 느꼈다.

## 8.다음 학습 계획
- get_next_line 수정
- get_next_line 테스트