# 학습 레포트 10일차 2021-01-08(금)
## 1.학습 날짜
> ### 2021-01-08(금)
## 2.학습 시간
> ### 20:00 ~ 00:00 (집)
> ### 00:00 ~ 07:00 (집) (2021-01-09 토)
## 3.학습 범위 및 주제
### | get next line 수정 및 보너스 구현 |
## 4.동료 학습 방법
- 온라인 - 슬랙 검색!!
## 5.학습 목표
- get next line 보너스 달성을 위한 코드 수정
## 6.상세 학습 내용
- **코딩에 사용된 시간** 약 8시간
- **참고한 내용** 슬랙 검색

### get_next_line 보너스 파트
- `static` 변수를 하나만 사용하여 구현하기.
- 파일의 끝을 읽기전에 다른 파일을 읽어도 각 파일들의 읽은 내용들을 잃지 않게 유지하기.

보너스 파트에서 구현해야 하는것은 두번째 항목인 파일을 읽는 중에 다른 파일을 읽게 되어도 이전 파일들의 읽던 내용을 잃지 않고 유지시킬 수 있도록 구현하는 것이다. 이전에 작성한 get_next_line 함수는 재귀함수형식을 가지고 있었고, 보너스 파트를 구현하기 위해서 코드를 반복문으로 수정을 하는것이 구현하는데 도움이 되었다.

처음에는 재귀 부분은 그대로 두고 읽어온 내용을 저장하는 mk_str 변수만 동적할당으로 바꾸어 수정하려 했는데, 재귀로 하려하면 계속 mk_str을 동적할당하고 free 하는 과정을 반복해 코드가 꼬이기 시작했었다. 그래서 방향을 바꾸고 반복문을 사용한 함수로 코드를 수정하게 되었다.

- if (read(fd, str, BUFFER_SIZE) > 0) 를 while (read(fd, str, BUFFER_SIZE) > 0)로.
반복문으로 수정하고 동적할당을 해주면서 코드가 많이 수정되었는데 읽은 내용을 mk_str에 저장하고 `\n` 이후 데이터를 유지시키는 포인트는 그대로 유지하였다. 따라서 코드의 흐름은 같다.
- `get_next_line(int fd, char **line)`
```c
while ((read_fd = read(fd, str, BUFFER_SIZE)) > 0)
{
    str[read_fd] = '\0';
    if (!mk_str[fd])
        mk_str[fd] = ft_strdup(str);
    else
    {
        tmp = ft_strjoin(mk_str[fd], str);
        free(mk_str[fd]);
        mk_str[fd] = tmp;
    }
    if (check_cr(mk_str[fd]) != -1)
        return (add_str(&mk_str[fd], line));
}
if (check_cr(mk_str[fd]) != -1)
    return (add_str(&mk_str[fd], line));
return (make_return(read_fd, &mk_str[fd], line));
```
이전 코드에서는 mk_str 에 값이 없으면 strlcpy로 동적할당 없이 str 버퍼의 값을 mk_str으로 복사 했는데 수정된 코드에서는 strdup 함수를 사용하였다.\
mk_str에 값이 있을 때는 strjoin 함수로 두 문자열을 합쳐주었고, 두 조건문 이후에 `\n` 을 체크해 개행이 있으면 add_str 함수를 호출하도록 하였다.

반복문 바깥의 if 조건문은 파일의 끝까지 다 읽고난 후 아직 mk_str에 값이 남아있다면 add_str 함수를 사용해 `\n` 까지 문자열을 잘라주도록 하였다.

이전 코드와 차이점은 개행 체크를 `read` 이전에 했던것을 read 이후 문자열을 전부 저장하고 체크를 해준다는 점이다. 그리고 strdup와 strjoin 함수를 사용했기때문에 mk_str을 free 해주는 작업이 필요했다.

- `add_str(char **mk_str, char **line)`
```c
while ((*mk_str)[i] != '\n')
    i++;
(*mk_str)[i] = '\0';
*line = ft_strdup(*mk_str);
tmp = ft_strdup(&(*mk_str)[i + 1]);
free(*mk_str);
*mk_str = tmp;
return (1);
```
add_str 함수도 tmp 임시 변수에 mk_str[fd]의 개행 이후 값을 복사하고 mk_str[fd]의 메모리를 해제 해준 후 tmp의 주소를 mk_str[fd]에 저장해 값을 유지가능하도록 하였다.

## 7.학습 내용에 대한 개인적인 총평
함수의 세부적인 작동방식은 동일하나 전체적인 구조를 바꾸느라 시간이 많이 들었다. `read`를 반복으로 읽게 하고, mk_str의 값을 저장하고 동적할당을 중복으로 하는것을 피하기 위해서 `free`를 적절히 사용해야 했다. 그리고 값을 복사하고 새롭게 할당을 하는 방법을 생각하기 힘이 들었다.\
여전히 동적할당을 하고 포인터를 자유자제로 사용하지를 못해 코드를 추가하고 수정하기에 오류가 정말 많이 발생했다. 특히 아직 왜 오류가 발생하는지 모르는 부분이 있는데 정적변수로 mk_str을 선언하고 동적할당을 하는것과 그냥 동적할당을 하는것의 차이점이 무엇인지 모르겠다. 포인터 배열의 크기의 문제인것 같기도한데 BUFFER_SIZE를 사용하는 str 변수에 static으로 데이터 영역에 만드는것이 맞다고 생각이 드는데 잘 모르겠다..\
수정한 get_next_line함수는 이제 정적변수를 하나만 쓰고 임시저장을 동적할당으로 변경하였기 때문에 서로 다른 파일을 읽게 되어도 fd를 인덱스로 다른 배열에 저장되기 때문에 읽었던 파일의 데이터 유지가 가능하게 되었다.\
보너스까지 우선 완성은 하였는데 static 변수에 대해서 좀더 공부하고 메모리 영역에 대해 공부를 해봐야 할것같다.

## 8.다음 학습 계획
- static 변수 공부!
- 메모리 영역 공부!
- get next line 평가받기!