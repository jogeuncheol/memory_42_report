# 학습 레포트 56일차 2021-03-23 (화)

## 1. 학습 날짜
> ### 2021-03-23 (화)

## 2. 학습 시간
> ### 22:00 ~ 24:00 (집)

## 3. 학습 범위 및 주제
### | 큰 수 A + B |

## 4. 동료 학습 방법
- hyeonpar 님

## 5. 학습 목표
- 백준 온라인 저지의 10757 번 문제인 큰 A + B 해결

## 6. 상세 학습 내용
- **실제 코딩 시간** 2시간
- **참고한 내용** 없음

### 큰 수 A + B
문제 : 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.\
입력 : 첫째 줄에 A와 B가 주어진다. (0 < A, B < 10^10000)\
출력 : 첫째 줄에 A + B를 출력한다.

### 해결을 위한 방법
먼저 문제에 대해 hyeonpar 님께 들었을 때 큰 수가 입력되면 숫자 말고 문자열로 처리한다는 말씀을 컴파일러가 그렇게 처리한다는 뜻으로 잘못 받아들였다. 한시간 정도 입력을 long long 형으로 처리하려 하다가 문자열로 입력받고 계산을 하면 될까라는 의문이 생겨 다시 생각해보니 hyeonpar 님 께서 말씀하신게 이 부분이었다는 것을 깨달았다.

1. 입력은 두 문자열을 입력 받는다. 두 문자열은 공백으로 구분되고 scanf 를 사용하면 쉽게 입력받을 수 있다.
2. 문자열의 길이는 10^10000 + 1 자리 수 이므로 배열 num1[10001], num2[10001]에 입력 받도록 해준다.
3. 문자열의 자릿수 연산은 각 문자열의 끝 문자 부터 더해 9 이상이면 끝에서 두 번째 값을 하나 증가시키며 첫 번째 수 까지 반복한다.
4. 마지막으로 출력을 한다.

위 4단계를 생각했고, 출력할 문자열의 최종 길이는 두 문자열의 길이와 같거나 하나 더 큰 수가 될 것이다.

### 코드
```c
#include <stdio.h>
#include <string.h>

void	arr_re(char *arr)
{
	char tmp;

	for (int i = 0; i < (strlen(arr) / 2); i++)
	{
		tmp = arr[i];
		arr[i] = arr[strlen(arr) - i - 1];
		arr[strlen(arr) - i - 1] = tmp;
	}
}

int		main()
{
	char num1[10001], num2[10001];
	char ans[10002];
	int c, len;

	memset(num1, 0, 10001);
	memset(num2, 0, 10001);
	memset(ans, 0, 10002);
	scanf("%s %s", num1, num2);
	arr_re(num1);
	arr_re(num2);
	if (strlen(num1) > strlen(num2))
		len = strlen(num1);
	else
		len = strlen(num2);
	for (int i = 0; i < len; i++)
	{
		if (num1[i] == '\0')
			num1[i] = num1[i] + '0';
		else if (num2[i] == '\0')
			num2[i] = num2[i] + '0';

		c = num1[i] - '0' + num2[i] - '0' + ans[i] - '0';
		if (c < 0)
			c = c + '0';
		if (c > 9)
		{
			ans[i + 1] = ans[i + 1] + 1 + '0';
			c = c % 10;
		}
		ans[i] = c + '0';
	}
	for (int i = 0; i < (strlen(ans) / 2); i++)
	{
		char tmp = ans[i];
		ans[i] = ans[strlen(ans) - i - 1];
		ans[strlen(ans) - i - 1] = tmp;
	}
	printf("%s\n", ans);
}
```
위 코드는 통과한 코드이다.\
arr_re 함수는 입력받은 두 문자열을 거꾸로 저장하는 함수이다. 결과적으로 문자열의 길이가 최고 길이 + 1이 될 수 있기 때문에 문자열을 뒤집어 더해가면서 값을 채우는게 편했다.\
memset 함수를 사용해 배열을 모두 0으로 초기화 해주었다.
```c
		if (num1[i] == '\0')
			num1[i] = num1[i] + '0';
		else if (num2[i] == '\0')
			num2[i] = num2[i] + '0';

		c = num1[i] - '0' + num2[i] - '0' + ans[i] - '0';
```
만약 num1 또는 num2 배열이 문자열의 끝에 도달했다면 두 값을 더해줄 때 숫자로 더할 수 없기 때문에 '0'을 더해 ascii 값으로 0에 해당하도록 만들어 주었다.

```c
c = num1[i] - '0' + num2[i] - '0' + ans[i] - '0';
```
결과 배열 ans 값을 더하는 것도 잊으면 안되었다.

```c
		if (c > 9)
		{
			ans[i + 1] = ans[i + 1] + 1 + '0';
			c = c % 10;
		}
		ans[i] = c + '0';
```
만약 두 값과 올림수가 있을지 모르는 ans 값을 더한 c가 10 이상이면 ans의 다음 자리에 값을 써 주고 c는 10으로 나누어 나머지를 갖도록 하였다. 이후 ans에 c 값을 써주었다.

```c
	for (int i = 0; i < (strlen(ans) / 2); i++)
	{
		char tmp = ans[i];
		ans[i] = ans[strlen(ans) - i - 1];
		ans[strlen(ans) - i - 1] = tmp;
	}
```
만들어진 ans 배열은 num1과 num2 를 거꾸로 더한 값 이므로 다시 한번 배열을 뒤집어 최종 결과를 만들어준다.

### 틀렸던 답

#### 1. 단순 오답
```c
#include <stdio.h>

int main()
{
    ssize_t a, b;

    scanf("%zu %zu", &a, &b);
    printf("%zu", a + b);
    return (0);
}
```
단순히 예로 들어준 9223372036854775807 + 9223372036854775808 = 18446744073709551615 값이 출력되어 제출을 했었다. 채점이 되지 않고 바로 틀렸다고 떳었다.

#### 2. 값 처리
```c
if ((c = num1[strlen(num1) - i - 1] - '0' + num2[strlen(num2) - i - 1] - '0') > 9)
{
    ans[i + 1] = ans[i + 1] - '0' + 1 + '0';
    c = c % 10;
}
```
값을 더해 10 이상인지 아닌지 판별해 주는 조건에서 c를 더할 때, ans를 무시하고 더해주었었다. 위 코드로는 ans값에 올림 수가 있어도 덮어 씌워 제대로 덧셈이 되지 않았었다.

## 7. 학습 내용에 대한 개인적인 총평
큰 수 더하기 문제는 시행착오가 많았다. 처음에 두 수를 입력 받을 때, 문자열로 입력받지 않고 숫자로 받아서 처리하려 했는데 시간이 많이 걸렸었다. 결국 숫자로 받을 수 있는 타입은 크기의 제한이 있기 때문에 정말 큰 수가 입력되면 처리 할 수 없었다. 그리고 문자열로 받아 각 자리 숫자를 더하고 올림이 있다면 다음 수에 1을 더하는 형식으로도 코드를 작성했는데, 이 방법도 마지막 자리에서 올림이 있으면 메모리 영역 초과 오류가 발생했다. 이러한 유형의 문제들을 많이 풀어보면서 앞에서 부터 연산하거나 뒤에서 부터 연산하는 것에 유연한 생각을 가질 수 있도록 연습하는 것이 좋겠다고 느꼈다.

## 8. 다음 학습 계획
- cub3D 또는 문제 풀이