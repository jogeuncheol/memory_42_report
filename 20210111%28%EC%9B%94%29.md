# 학습 레포트 11일차 2021-01-11(월)
## 1.학습 날짜
> ### 2021-01-11(월)
## 2.학습 시간
> ### 20:00 ~ 00:00 (집)
> ### 00:00 ~ 01:00 (집)
## 3.학습 범위 및 주제
### |get next line 과제, static 변수와 지역변수 malloc 주소의 변화 등|
## 4.동료 학습 방법
- 온라인 - hyi님, seshin님과 토론
## 5.학습 목표
- 초기화 되지 않은 지역변수의 동적할당시 값의 변화
- static 변수와 지역변수
- printf의 내부 동작에 의한 포인터 참조?
## 6.상세 학습 내용
- **코딩에 사용된 시간** 약 2시간
- **참고한 내용** 슬랙 검색, [메모리 구조1](https://ggodong.tistory.com/38), [메모리 구조2](https://m.blog.naver.com/PostView.nhn?blogId=ahalinux&logNo=220768423009&proxyReferer=https:%2F%2Fwww.google.co.jp%2F)

### BUFFER_SIZE와 스택의 크기
지난주 작성했던 과제 get next line 함수를 테스트 하던 중 BUFFER_SIZE 가 유닉스 기본 스택사이즈를 초과하게 되면 스택 오버플로우가 발생하게 되는데, 이는 과제 subject에도 적혀있어 확인을 했었던 부분이다. 이 부분을 함수 작성을 끝내고 다시 확인했던 이유가 슬랙에도 검색을 많이 해보았는데 스택 오버플로우를 해결해주어도 안해주어도 괜찮은것 같다는 개인적인 결론을 내었었다.\
하지만 과제 subject에는 왜 발생하는지에 대해 알면 괜찮은것 같았지만, 그래도 정적변수 혹은 동적 할당으로 힙 영역에서 사용을 하게되면 BUFFER_SIZE가 커져도 시스템 메모리안에서 동작하도록 변경하고 싶었다.\
터미널에서 `ulimit -a` 명령어를 통해 유닉스의 기본 스택 크기를 알수있었는데 8MB로 되어있음을 알게되었다. 그리고 같은 명령어를 사용해서 file descriptor의 기본 크기인 256도 알게되었다. 다음 항목에 작성할 오류내용은 file descriptor와 연관이 되어있다.

먼저 작성했던 get_next_line 함수의 변수 선언은 다음과 같이 되어있었는데
```c
char        *tmp;
char        *mk_str[256];
static char str[BUFFER_SIZE + 1];
```
mk_str 변수는 `read` 를 통해 읽어온 데이터를 동적할당으로 저장하는 변수이고, str 변수는 `read`시 읽은 데이터가 저장되는 버퍼로 사용하였다.
`str` 배열의 크기는 컴파일시 `-D BUFFER_SIZE=32` 와 같이 지정이 되는데 스택 크기를 넘어가는 수가 들어오게 되면 str 배열의 크기가 스택의 공간을 넘어서 힙 영역 공유 공간을 침범하게되는 스택 버퍼 오버플로우가 발생한다. 따라서 나는 static으로 data 영역에 저장되도록 하여 스택 크기에 간섭받지 않도록 코드를 작성했었다.

### char \*mk_str[256] 사용시 메모리 할당과 주소에 대한 잘못된 사용
위 항목과 이어지는 부분으로 BUFFER_SIZE로 인한 스택 오버플로우를 피하기위해 str 변수를 정적으로 선언하였었다. static으로 변수 선언을 함으로 해결을 했다고 생각하고 다음 변수인 mk_str의 크기를 바꿔가면서 테스트를 해보았는데 여기서 자꾸 다른 코드와 연관되는 오류가 발생하였고, 오류에 대해서 seshin님과 hyi님께 도움을 요청했다.

### mk_str 포인터 배열의 오류
mk_str 포인터 배열의 크기를 정할 때, 슬랙에서 본 OPEN_MAX 값을 처음에 이용했었고 그때에는 문제가 없었다. 하지만 `ulimit -a`명령어로 file descriptor의 기본 크기를 확인 한 후 mk_str의 크기를 256으로 사용하고 싶어 수정하자 다른 코드에서 문제가 발생했다.
```c
if (!mk_str[fd])
    mk_str[fd] = ft_strdup(str);
else
{
    tmp = ft_strjoin(&mk_str[fd], str);
    free(mk_str[fd]);
    mk_str[fd] = tmp;
}
```
mk_str 변수 선언시 배열의 크기를 256으로 선언 하자 할당되지 않은 메모리를 해제하려 한다는 오류 메시지가 발생하였다. 하지만 이상했던것은 코드를 테스트 하다보면 작동을 제대로 할 때도 있었고, 다른 터미널을 열면 작동이 되기도 하고 말썽이 많았다.\
작성한 코드에서 free() 함수를 처음 호출하는 부분인 if-else 에서 발생 했다는것을 찾았고, 왜 그런지 선언 이후 mk_str[fd] 의 값을 확인해본 결과 초기화 시키지 않은 것이 문제라는것을 알게 되었다.\
변수를 초기화 시키지 않고 선언만 하게되면 0으로 초기화를 해주기도 하지만 대부분 초기화 해주지 않는다 그리고 **포인터변수는 자동으로 초기화 되지 않음을 알게되었다** 다른 시스템에서 확인을 해보진 못했지만 원격으로 클러스터 맥의 환경에서는 자동으로 초기화 되지 않는다고 알게되었다.

포인터 배열들의 값들을 출력해본 결과 배열의 크기에 따라 어떤 구간은 0으로 되어있기도 하고 또 다른 구간은 예상치 못한 값이 들어있기도 했다. 이는 시스템에서 사용중인 공간이거나 다른 데이터를 사용중인 공간임을 알 수 있었다. **실제로 초기화하지 않은 포인터 배열의 값과 포인터가 가르키는 값을 출력해보니 쉘의 현재 경로가 출력되기도 했다!!**\
그래서 가장 처음 `get_next_line` 함수를 불러 읽을 때, 초기화되지 않은 변수 mk_str[fd] 안에 주소가 0이 아닌 다른 시스템에서 사용중인 곳을 가리켰고, 그때는 `if (!mk_str[fd])`에서 체크되지 않기 때문에 `else`문의 free(mk_str[fd]) 를 호출했고,  할당되지 않은 포인터였기 때문에 오류가 발생한 것이었다.

항상 과제를 진행할 때 `-Wall -Wextra -Werror`옵션으로 초기화 하지않은 변수를 확인 했었는데 mk_str 변수의 경우 해당 옵션에서도 걸리지 않아 초기화의 문제를 잊고 있었다. 변수의 초기화가 중요한 이유를 다시한번 깨닫게 되었다.

### 지역 변수로 설정한 포인터의 동적할당
mk_str 변수의 초기화의 문제를 확인했고 수정을 하려 했는데 또 한가지 문제가 있었다. mk_str 변수는 지역변수로 선언을 해두었는데 그 이유로 동적할당을 할것이기 때문에 static으로 하지 않아도 상관없을것이라는 생각을 하고 있었다. 하지만 이것 또한 예상치 못한 오류로 이어질 수 있음을 알게되었다.

나는 동적할당으로 주소를 가지게 하면 함수가 끝이나도 다시 불러왔을 때 해당 변수는 할당된 주소를 알고 있을테니 잘 찾아갈것 이라고 생각했다. 하지만 이러한 방식은 지역변수는 함수의 끝과 함께 종료되고 함수의 시작시 다시 시작한다는점에서 큰 오류가 있을 수 있었다. 운 좋게도 시스템에서 이전에 할당되었던 주소를 찾아 결과를 제대로 출력 되었던 것이라 생각하게 되었다.

### printf와 동적할당의 관계?
아직 해결하지 못한 문제도 있었다. 지역변수로 선언된 mk_str변수의 사용시 운 좋게 get next line 함수가 작동이 되었지만 테스트 중 할당되지 않은 메모리의 해제 오류가 발생했을 때, 함수의 내부에서 어디서든 mk_str을 사용한 printf 함수가 있을 때, 메모리 해제 오류가 발생하지 않고 작성한 코드가 정상 작동하는것 처럼 출력이 되는 것을 보았다.\
printf함수의 인자로 mk_str을 부르면 시스템에서 이전에 할당된 주소를 먼저 체크해 오류가 나지않고 출력되었던것 같다. 이것에 대해서는 아직 정확한 이유는 모르겠지만 hyi 님께서 fr_printf 과제를 하셨는데 함수에서 동적 할당을 사용하셨다고 들어서 동적할당과 시스템에서 메모리 주소를 우선적으로 처리하는 과정이 있는지 확인을 더 해보아야겠다. printf 과제를 진행하면서 더 자세히 알아 볼 수 있으면 좋겠다.

## 7.학습 내용에 대한 개인적인 총평
get_next_line 함수의 오류와 메모리의 잘못된 사용을 hyi님, seshin님과 이야기 할 수 있어서 정적 변수와 지역 변수, 포인터 사용법에 대해서 다시 배울 수 있어서 정말 좋은 시간이었다. mk_str 포인터 변수를 지역변수로 선언했을때, 초기화 되지않은 변수의 사용과 특히 메모리를 사용해야 할 때에는 초기화를 더욱 조심해야 한다는것을 다시 깨닫게 되었다.\
오류가 발생하는 코드에서 메모리사용에 따라 정상적이지 않은 작동은 더욱 위험하기 때문에 코드를 작성할 때 메모리를 한번 더 생각하고 사용해야겠다고 느꼈다.

## 8.다음 학습 계획
- get_next_line 과제 테스트와 평가 받아보기