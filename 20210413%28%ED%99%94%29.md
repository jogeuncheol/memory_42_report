# 학습 레포트 66일차 2021-04-13 (화)

## 1. 학습 날짜
> ### 2021-04-13 (화)

## 2. 학습 시간
> ### 14:00 ~ 18:00 (집)
> ### 22:00 ~ 24:00 (집)

## 3. 학습 범위 및 주제
### | 벽 색깔 바꾸기 |

## 4. 동료 학습 방법
- 해당 없음

## 5. 학습 목표
- 벽의 색깔을 바꿔본다.

## 6. 상세 학습 내용
- **실제 코딩 시간** 5시간
- **참고한 내용** 없음

### 벽 그라데이션

이전에 배경색깔의 그라데이션을 넣어본 적이 있어 이번에는 벽이 멀리 있으면 어둡게, 가까이 있으면 원색으로 보이도록 수정을 해 보았다. 계산으로 구한 dst를 일정 값 구간에 따라 색을 어둡게 해 주었다.

```c
void screen_pixel_put(t_param *param, int width_inc, float fov)
{
...
    dst;
    
    int color;
    if (dst < 20)
        color = 0x0000ff;
    else if (dst < 30)
        color = 0x0000ef;
    else if (dst < 50)
        color = 0x0000df;
    else if (dst < 100)
        color = 0x0000af;
    else if (dst < 200)
        color = 0x00005f;
    else
        color = 0x00001f;
...
}
```
벽의 색을 지정하는 구간이 if문으로 나눠 두었다. 원색을 `0x0000ff`로 파랑색이고 거리가 멀수록 검정색에 가까워 지도록 해 두었다.\
하지만 위 방식에는 문제가 있었다. 플레이어로 부터 거리 구간이 제한이 되어있고 값의 경계가 분명하다는 것이었다. 또 회전을 하면 거리가 바뀌므로 벽 색깔이 변화되는 것이 눈에 띄었다.

```c
    color = (color - dst * 2) > 0x00001f ? color - (dst * 2) : 0x0;
```
처음 작성한 코드의 문제점을 찾고 위 방법으로 코드를 수정하였다. color값을 최소로 표현 해 줄 값보다 크다면 `원색 - 거리`를 적용 해 색을 어둡게 만들어 주었다. 거리에 2를 곱한 이유는 멀리있으면 더 값을 많이 빼, 어둡게 해주기 위함이다. `어두움의 배수`가 된다.\
코드를 수정하고 더 자연스러운 그라데이션 표현이 되었고, 천장과 바닥의 그라데이션에도 잘 어울렸다.

### 벽의 4가지 색깔

다음은 벽의 방향에 따라 색을 다르게 지정하고 싶었다. 실제로 과제의 필수 영역이 벽을 서로다른 4가지 텍스처를 적용해야 할 수 있어야 하기 떄문에 한번 다른 색을 지정 해 보도록 해보았다.

```c
    if ((int)floor(param->xy.x1) % TILE_SIZE == 0)
        color = 0x0000ff; // 동
    if ((int)floor(param-.xy.x1 + 1) % TILE_SIZE == 0)
        color = 0xacacff; // 서
    if ((int)floor(param->xy.y1) % TILE_SIZE == 0)
        color = 0xffacac; // 북
    if ((int)floor(param->xy.y1 + 1) % TILE_SIZE == 0)
        color = 0xacff00; // 남
    color = (color - dst * 2) > 0x00001f ? color - (dst * 2) : 0x0;
```

param->xy.x1, param->xy.y1 값은 플레이어로 부터 광선이 벽에 닿았을 때 좌표 값을 저장한 값들 이다. 이 값들을 사용해 동, 서, 남, 북 값을 설정 할 수 있었다.

param->xy.x1을 TILE_SIZE로 나눈 나머지가 0인 경우 동쪽, param->xy.x1 + 1을 TILE_SIZE로 나눈 나머지가 0인 경우 서쪽이 된다. 왜냐하면 각각의 벽은 TILE_SIZE만큼의 두께를 가지도록 설정 해 놨고, 각 격자는 TILE_SIZE 만큼씩 이동하여 설정되어있다. 그러므로 TILE_SiZE에서 딱 만나는 점들은 동쪽과 북쪽이 될 것이다. 따라서 동쪽과 북쪽은 각 x1, y1 값을 TILE_SIZE로 나눈 나머지를 확인하고, 서쪽과 남쪽은 만난 좌표에서 +1 을 해 나눈 나머지를 확인하면 된다.

## 7. 학습 내용에 대한 개인적인 총평

## 8. 다음 학습 계획
- cub3D 공부