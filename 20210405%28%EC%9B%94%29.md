# 학습 레포트 60일차 2021-04-05 (월)

## 1. 학습 날짜
> ### 2021-04-05 (월)

## 2. 학습 시간
> ### 17:00 ~ 20:00 (집)
> ### 22:00 ~ 24:00 (집)

## 3. 학습 범위 및 주제
### | cub3D ray 충돌 |

## 4. 동료 학습 방법
- 해당 없음

## 5. 학습 목표
- cub3D ray의 벽 충돌 방법

## 6. 상세 학습 내용
- **실제 코딩 시간** 4시간
- **참고한 내용** 없음

### 방향 ray의 길이
작성한 테스트 코드는 임의로 방향 ray의 길이를 50 픽셀로 제한 하고 해당 좌표 값을 통해 윈도우에 ray를 그리도록 되어있었다. 이것을 맵의 벽을 만나면 ray를 그만 그리도록 하고 싶었고, 수직의 벽을 그리기 위해서도 벽을 만나면 ray를 그리는 것을 멈추고 해당 좌표까지의 거리를 계산해 벽을 그려주어야 하기 때문에 맵 내에서 ray를 계속 그리다가 벽에 해당하면 멈추는 코드가 필요 했다.

### tile_size 와 ray
로데브의 레이캐스팅이나, 다른 유투브의 레이캐스트 영상들을 보면 수직의 벽을 그릴때 어떤 방법을 사용할지 설명을 해 준다.
1. 플레이어로부터 ray를 쏴, 해당 좌표를 모두 검사하며 벽을 만나면 정지한다.
2. 플레이어로부터 ray를 쏘는데 일정한 거리를 두고 검사하며 해당 좌표가 벽과 만나면 정지한다.
3. 플레이어로부터 ray를 쏘는데 맵의 일정한 그리드를 기준으로 검사하며 그리드 내에 수직, 수평 좌표가 벽에 해당하면 정지한다.

위 세가지 방법을 소개 해 주는데, 1번은 연산량이 엄청 많아지기 때문에 효율적이지 못한 방법이다. 왜냐하면, 벽을 만날 때 까지 계속 좌표 하나하나 검사를 하기 때문이다.
2번 방법은 일정한 거리를 두고 검사하기 때문에 괜찮아 보이지만, 만약 검사하는 점과 점 사이에 벽이 존재 했다면, 벽을 검사하지 못할 수 있기 때문에 좋지 못한 방법이다.
3번 방법을 대부분의 강의 영상에서 사용하였는데, 맵에 그리드, 격자가 있다고 생각하고 해당 격자의 수직, 수평 한곳에 ray가 닿으면 검사를 하는 방식이다. 수직 격자에 ray가 닿았을 때 검사를 하고, 벽이 아니라면 다음 수직 또는 수평 격자를 만날때 다시 검사를 한다.\
3번 방법이 효율적인 이유는 플레이어의 위치부터 처음 만나는 격자를 제외하면 두번째 격자까지의 거리와 세번째, 네번째 ... 이후 격자까지의 수직, 수평 거리는 계속 동일하기 때문에 단순히 거리만큼 더해주면 벽 검사가 가능하다는 점이다.

### 코드
```c
    while (i < step)
	{
		mlx_pixel_put(param->mlx_ptr, param->win_ptr, param->xy.x1, param->xy.y1, 0xffff);
		param->xy.x1 = (param->xy.x1 + xinc);
		param->xy.y1 = (param->xy.y1 + yinc);
		printf("x1, y1 : %f %5f\n", param->xy.x1, param->xy.y1);
		i++;
	}
```
작성했던 방향 ray를 그리는 반복문 부분이다.\
step은 플레이어 좌표와 방향 ray의 좌표 즉 플레이어로부터 50픽셀 만큼 떨어진 좌표값의 차이를 통해 step수를 알아내고 x증가량과 y증가량을 더해 픽셀을 그려준다.

```c
    while ((WINDOW_WIDTH - param->xy.x1 > 0) && (WINDOW_HEIGHT - param->xy.y1 > 0))
	{
		if (param->xy.x1 < 0 || param->xy.y1 < 0)
			break;
		mlx_pixel_put(param->mlx_ptr, param->win_ptr, param->xy.x1, param->xy.y1, 0xffff);
		param->xy.x1 = param->xy.x1 + xinc;
		param->xy.y1 = param->xy.y1 + yinc;

		if (wall[(int)floor(param->xy.y1 / TILE_SIZE)][(int)floor(param->xy.x1 / TILE_SIZE)] == 1)
		{
			break;
		}
	}
```
조건만 추가를 해주었는데
```c
while ((WINDOW_WIDTH - param->xy.x1 > 0) && (WINDOW_HEIGHT - param->xy.y1 > 0))
{
    if (param->xy.x1 < 0 || param->xy.y1 < 0)
		break;
    ....
}
```
ray가 WINDOW_WIDTH, WINDOW_HEIGHT 보다 커지거나 0보다 작아지면 반복을 중지하도록 해서 플레이어로부터 ray를 맵 끝까지 그리도록 하였다.

```c
if (wall[(int)floor(param->xy.y1 / TILE_SIZE)][(int)floor(param->xy.x1 / TILE_SIZE)] == 1)
{
	break;
}
```
wall은 맵의 배열이고, floor 함수는 math.h 에 저장되어있는 임의의 값 보다 작은 최대의 정수 값을 반환한다. 예를 들어 값이 5.4라면 5.4보다 작은 최대의 정수는 5이다.\
ceil 함수는 보다 큰 최소의 정수를 반환하는 함수로 5.4보다 큰 최소의 정수는 6이다.\
따라서 각 ray의 좌표값을 tile_size로 나누고 floor 함수로 보다 작은 최대의 정수로 만들어 주면 각 좌표에 해당하는 격자의 첫 좌표를 알 수 있다.\
만약 param->xy.x1 / tile_size 가 5.4 였다면 floor(5.4) 는 5가 될 것이고 만약 x, y 가 5, 5 라면 wall 배열의 5, 5 좌표를 확인 할 수 있다.\
위 방법은 위에서 설명한 1번 방법일 것이다. 각 좌표마다 wall 배열의 값과 비교해 값이 1이면 중지하고 0이면 계속 반복한다. 단순히 ray만 그릴 때는 괜찮겠지만, 앞으로 코드 작성을 하다보면 성능저하도 많이 될것이라 생각한다.

### 해결법
아직 코드로 바꾸지는 못했지만, 위에서 찾은 배열의 좌표에 tile_size를 곱하면 처음 플레이어가 위치한 격자를 알 수 있고, 첫 좌표를 알면 다음 격자의 위치는 tile_size 만큼 더하거나 빼면 앞으로 나타날 격자를 계산할 수 있고, 3번 처럼 연산 횟수를 줄여 나갈 수 있을 것이다.

## 7. 학습 내용에 대한 개인적인 총평
방향ray를 무한히 그리면서 벽에 해당하는 좌표에 닿으면 ray 그리기를 멈추도록 해보았다. 여러 영상들을 보면서 그리드까지 거리를 계산하고 벽 검사를 해보려 했는데 어떻게 계산하면 좋을지 잘 떠오르지 않아 먼저 1번처럼 연산을 계속 하게 만들어 먼저 테스트를 진행했다. 해결방법처럼 고쳐보면 될것 같기도 하고 여라가지 시도를 해보아야겠다.

## 8. 다음 학습 계획
- cub3D 공부