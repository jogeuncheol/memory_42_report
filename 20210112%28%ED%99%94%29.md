# 학습 레포트 12일차 2021-01-12(화)
## 1.학습 날짜
> ### 2021-01-12(화)
## 2.학습 시간
> ### 20:00 ~ 00:00(집)
## 3.학습 범위 및 주제
### | 스택 오버플로우, NULL 포인터의 free |
## 4.동료 학습 방법
- 온라인 - seshin님과 토론
## 5.학습 목표
- 스택 오버플로우
- NULL 포인터의 free
## 6.상세 학습 내용
- **코딩에 사용된 시간** 약 2시간
- **참고한 내용** [free 이후 NULL 넣어주기](https://www.benjaminlog.com/entry/checking-null-pointer-before-delete-some-memory), [free 하기 전 NULL 체크](https://stackoverflow.com/questions/1912325/checking-for-null-before-calling-free)), [NULL포인터를 free 하는 경우](https://stackoverrun.com/ko/q/1515149), [메모리 해제 문제](https://www.hanbit.co.kr/network/category/category_view.html?cms_code=CMS4640778364)

### get_next_line 과제에서 BUFFER_SIZE 에 따른 스택 오버플로우발생
GNL 과제에서는 컴파일시 `-D BUFFER_SIZE=32` 와 같이 BUFFER_SIZE를 지정하여 컴파일 하도록 되어있다. 이 때 BUFFER_SIZE의 값이 너무 크면 이 BUFFER_SIZE를 사용하는 변수의 메모리 영역에 따라 오류가 발생 할 수 있다. 나의 코드의 경우 `read`함수의 버퍼로 `str` 변수를 배열로 만들었는데 지역 변수로 `str[BUFFER_SIZE + 1]` 과 같이 선언 하여 사용하였었다.

과제의 subject에도 나와있는 질문중 BUFFER_SIZE가 10000000일때 어떻게 작동하는가? 왜 그렇게 작동하는가에 대해 처음 배열로 작성 했을 때는 스택 오버플로우가 발생했다. 왜 그런지 알아보니 스택 영역의 크기가 유닉스의 경우 기본 8MB로 잡혀있다고 한다. `ulimit -a` 명령어를 통해 해당 실제 스택 영역의 기본 크기를 확인 할 수 있었다.

### 스택 오버플로우 피하기
`str`변수를 스택영역에서 사용하게되면 입력받는 BUFFER_SIZE의 크기에 따라 프로그램이 정상 작동하지 못할것이다. 따라서 `str`변수를 동적할당 하여 힙 영역에서 사용되도록 수정을 하였다.
```c
char *str;
str = (char *)malloc(sizeof(char) * (BUFFER_SIZE + 1));
while (...)
{
...
}
free(str);
...
```
힙 영역의 경우 시스템의 메모리가 충분한 이상 사용이 가능하기 때문에 더이상 스택 오버플로우같은 오류가 발생하지 않았다. 스택 오버플로우를 막기위해 동적할당을 이용한 힙 영역 사용 외에 정적변수, 전역변수를 사용하여 데이터 영역에 사용되도록 하여도 되지만, 과제의 조건인 전역변수 사용금지와, 보너스 파트의 정적변수는 하나만 사용하기를 달성하기 위해 동적할당을 이용해 힙 영역에서 사용하도록 하였다.

### NULL 포인터의 free
작성한 GNL 코드 중
```c
if (mk_str[fd])
    free(mk_str[fd]);
```
부분에서 mk_str은 `static`으로 선언이 되어있었다. 만약 mk_str[fd]에 주소값이 있다면 free()를 먼저 하도록 해준 것인데, 이부분에서 seshin님께서 질문을 주셨다.\
일반 포인터 변수를 메모리 할당을 하지 않고 free하게되면 할당되지 않은 메모리 free 오류가 발생하는데, `static` 포인터 변수를 그냥 free하게 되면 메모리 free 오류가 발생하지 않는다는 것을 알려주셨다. static 변수의 경우 초기화하지 않으면 자동으로 0으로 초기화를 해주는것을 GNL 과제를 하면서 알게되었는데 NULL 포인터를 free하게 되면 어떻게 작동하는지는 몰랐었다. [NULL포인터를 free 하는 경우](https://stackoverrun.com/ko/q/1515149) 검색을 통해 알게된것이 NULL 포인터의 경우 free함수에서 아무 작동도 하지 않는다는 것이었다.

- 새롭게 알게된 내용 **free(NULL)**
free 함수의 경우 NULL 포인터는 아무 작동도 하지 않는다. 그렇다면 코드에서 해당 지울까 생각도 해보았지만 이전에 주제로 나왔던 free 이후 NULL을 넣어주는것을 생각해보니 필요하다고 느껴져 수정을했다.
```c
if (mk_str[fd])
{
    free(mk_str[fd]);
    mk_str[fd];
}
```
위 코드는 mk_str[fd]에 주소가 있으면 free하고 mk_str[fd]에 NULL을 넣는것이다.\
이전에 주제에서 다루었던 free이후 NULL을 넣어주는것이 단번에 이해가 되었다. 프로그램 동작중 예상치 못하게 이전에 한번 free했던 주소를 다시 free하게되면 이중free 오류가 발생하기 때문에 해제한 포인터에 NULL을 넣어 두번이상 중복으로 해제 하지 못하도록 막아주는 안전장치라는 생각이 들었다.

## 7.학습 내용에 대한 개인적인 총평
## 8.다음 학습 계획
- get_next_line 평가받기

str[BUFFER_SIZE + 1] 변수를 \*str 으로 바꿈 -> BUFFER_SIZE 로 인한 스택오버플로우를 막기위해서 동적 할당으로 해결.
free 와 = NULL 추가.