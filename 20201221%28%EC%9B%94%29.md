# **학습 레포트 1일차 2020-12-21(월)**
## **1.학습 날짜**
> ### **2020-12-21 (월)**
## **2.학습 시간**
> ### **12:10 ~ 15:25 집**
> 휴식
> ### **16:32 ~ 19:57 집**
> 저녁 식사
> ### **21:03 ~ 22:50 집**

## **3.학습 범위 및 주제**
### | Libft part1 
> ft_memset\
> ft_bzero\
> ft_memcpy\
> ft_memccpy\
> ft_memmove\
> ft_memchr\
> ft_memcmp\
> ft_strlen\
> ft_strlcpy\
> ft_strlcat\
> ft_strchr\
> ft_isalpha\
> ft_isdigit\
> ft_isalnum\
> ft_isascii\
> ft_isprint\
> ft_toupper\
> ft_tolower\
> ft_atoi\
> ft_strncmp

## **4.동료 학습 방법**
- 온라인 - 슬랙이용.
## **5.학습 목표**
- Libft 과제를 읽어보고 part1 코드 작성하기.

## **6.과제 제출 repository 주소**
## **7.상세 학습 내용**
### ft_memset
- **형식**\
`memset(void *b, int c, size_t len)`
- **반환 값**\
`void *` 형 데이터
- **설명**\
memset 함수는 len byte 만큼 b 문자열에 c 값을 쓴다.
메모리를 특정 값을 채우기 위해 사용한다.
- **주목할 점**\
`int c` 타입은 `int`지만 내부적으로 `unsigned char`로 변환된다.\
만약 `memset(dst, 0, 10);` 을 한다면 dst의 처음부터 10byte만큼 0으로 초기화 한다.\
`unsigned char`형으로 변환된 0은 `NULL`이므로 dst의 처음 10byte는 NULL로 초기화 된다.\
만약 dst == hello world 였다면 \0\0\0\0\0\0\0\0\0\0d가 된다.
- **`char`형으로 사용될 `c`를 `int`형으로 받는 이유에 대하여**\
앞의 다른 인자도 `void *`로 받는 이유와 비슷할 것이라 생각되었다.\
메모리에 어떤 자료형이 오더라도 memset을 가능하게 하기 위함이 아닌가 생각이 들었다.\
`int` 자료는 정수를 받아 함수 내부에서 그게 해당하는 아스키값을 가지게 할 수 있기 때문이라고 생각했다.
- **주요 코드**
```c
while (i < len)
{
    *((unsigned char *)b + i) = (unsigned char)c;
    i++;
}
```
- **끝으로**\
내부적으로 `unsigned char`로 변환됨을 주의깊게 보았다.

### ft_bzero
- **형식**\
`bzero(void *s, size_t n)`
- **반환 값**\
`void *` 형 데이터
- **설명**\
`n`byte 만큼 `s` 문자열에 0으로 초기화 한다.\
만약 `n`가 0이라면 아무것도 하지 않는다.
- **주요 코드**
```c
if (n == 0)
    return ; /* n이 0이라면 아무것도 하지 않는다. */
else
{
    while (i < n)
    {
        if (*(char *)s + i) == 0)
            break ;
        *((char *)s + i) = 0;
        i++;
    }
}
```

### ft_memcpy
- **형식**\
`memcpy(void *dst, void *src, size_t n)`
- **반환 값**\
`void *` 형 데이터
- **설명**\
`n`byte 만큼 `src`에서 `dst`로 복사한다.
src와 dst가 겹치면 동작이 정의되지 않는다.
- **주목할 점**\
`dst`와 `src`가 같은 주소를 참조하는 경우 예상한 결과가 나오지 않을 수 있다.
`memcpy` 함수의 경우 빠른 속도로 src의 데이터를 dst로 복사하는 함수로 안전하지 않다고 한다.
`memmove` 함수를 사용하면 속도는 `memcpy`보다 느리지만 안전한 복사가 가능하다고 한다.
`memmove()` 함수를 설명할 때 풀어쓰겠습니다.

## **8.학습 내용에 대한 개인적인 총평**
## **9.다음 학습 계획**
- Libft part1 정리.
- Libft part1 나머지 코드를 작성하기 위해 동적할당과 Makefile 작성법에 대해서 공부하기.
- (*보너스 목표*)Libft part2 코드 살펴보기.
