# 학습 레포트 37일차 2021-02-25(목)

## 1.학습 날짜
> ### 2021-02-25(목)

## 2.학습 시간
> ### 18:30 ~ 20:36(집)
> ### 20:29 ~ 21:50(집)

## 3.학습 범위 및 주제
### | 문자열 처리 |

## 4.동료 학습 방법
- 온라인 - 42 디스코드 검색

## 5.학습 목표
- exam rank 02 의 시험에 대해서 알아보고 코드 작성해보기

## 6.상세 학습 내용
- **실제 코딩 시간** 2시간 30분
- **참고한 내용** 42 디스코드 exam_rank02 채널

### 본과정의 시험
본과정에서 첫 시험이 있는 2서클에 도착을 했다. 2서클의 과제는 ft_server, cub3D 또는 miniRT 세가지 과제가 있고, cub3D와 miniRT는 그래픽 과제로 하나만 선택할 수 있다고 한다. 2서클을 통과하기 위해서는 exam_rank_02를 통과해야 한다고 한다. 한동안 covid-19의 상황이 좋지 않아 시험을 보지 않고 다음 서클의 과제를 진행하는 것을 임시로 허용 하고 있었는데 다시 원래 규정대로 돌아왔다고 한다.\
exam_rank_02의 문제는 랜덤으로 두 문제가 출제된다고 한다. 피신 시험 때 작성 해 보았던 inter 와 union 함수 중 하나와 1써클의 get_next_line, ft_printf 중 하나가 나온다고 한다.

### union
union 프로그램은 두 문자열에 나타난 문자를 중복없이 모두 출력하는 문제였다. 피신 3주차 시험과 마지막 시험에서 시간을 많이 잡아먹었던 문제로 기억한다.

```c
#include <unistd.h>

int main(int argc, char *argv[])
{
    int i;
    int j;
    int k;
    
    i = 0;
    j = 0;
    if (argc == 3)
    {
        while (argv[1][i] != '\0')
        {
            k = 0;
            while (k < i - 1)
            {
                if (argv[1][k] != argv[1][i])
                    k++;
                else
                    break ;
            }
            if (argv[1][k] == argv[1][i] && k <= i - 1)
            {
                i++;
                continue ;
            }
            if (argv[1][i] == argv[2][j])
            {
                write(1, &argv[1][i], 1);
                i++;
                j++;
            }
            else
            {
                write(1, &argv[1][i], 1);
                i++;
            }
        }
        while (argv[2][j] != '\0')
        {
            k = 0;
            while (k < j - 1)
            {
                if (argv[2][k] != argv[2][j])
                    k++;
                else
                    break ;
            }
            if (argv[2][k] == argv[2][j] && k <= j - 1)
            {
                j++;
                continue ;
            }
            k = 0;
            while (k < i)
            {
                if (argv[1][k] != argv[2][j])
                    k++;
                else
                    break ;
            }
            if (argv[1][k] == argv[2][j])
            {
                j++;
                continue ;
            }
            else
            {
                write(1, &argv[2][j], 1);
                j++;
            }
        }
        write(1, "\n", 1);
    }
    else
        write(1, "\n", 1);
    return (0);
}
```
다른 함수를 작성하지 않고 main 함수 하나로 작성했는데 작성한 union 프로그램의 작동방식은 2부분으로 나눌 수 있다.
```
1. 앞 문자열에 등장한 문자를 출력한다.
2. 뒤 문자열에 등장한 문자를 출력한다.
```
```
1-1. 앞 문자열에 등장한 문자를 출력하면서 중복되지 않도록 나왔던 문자는 넘어갈 수 있도록 처리해 준다.
1-2. 앞 문자열에 등장한 문자가 뒤 문자열에 등장하면 뒤 문자열의 인덱스를 하나 늘려준다.
1-3. 앞 문자열 중 이전 문자들과 중복되지 않는 문자를 출력해 준다.
```
```
2-1. 뒤 문자열에 등장한 문자를 출력하는데 중복되지 않도록 나왔던 문자는 넘어갈 수 있도록 한다.
2-2. 앞 문자열에 나온 문자는 출력하면 안되므로 앞 문자열과 뒤 문자를 비교해 같으면 인덱스를 하나 늘려준다.
2-3. 앞 문자열에서 등장하지 않았고, 뒤 문자열중 이전 문자들과 중복되지 않는 문자를 출력해 준다.
```
작성 해본 union 프로그램의 작동 순서이다. 피신 시험 때 작성 했던 코드를 다시 생각해보면 너무 어렵게 생각 했던것 같다. 출력한 문자를 가장 처음 등장한 문자로 바꿔가면서 출력을 해줬던 기억이 난다.

### inter
inter 프로그램 작성 문제는 피신기간 시험 중 3주 연속으로 나왔던 문제로 기억을 하고 있다.\
프로그램의 인자로 주어지는 두 문자열에 모두 등장하는 알파벳을 앞 문자열의 순서로 출력하는 문제 였던 것으로 기억한다.
```c
#include <unistd.h>

int main(int argc, char *argv[])
{
    int i;
    int j;
    int k;
    
    i = 0;
    j = 0;
    if (argc == 3)
    {
        while (argv[1][i] != '\0')
        {
            k = 0;
            while (k < i - 1)
            {
                if (argv[1][k] != argv[1][i])
                    k++;
                else
                    break ;
            }
            if (argv[1][k] == argv[1][i] && k <= i - 1)
            {
                i++;
                continue ;
            }
            j = 0;
            while (argv[2][j] != '\0')
            {
                if (argv[1][i] == argv[2][j])
                {
                    write(1, &argv[1][i], 1);
                    break ;
                }
                else
                    j++;
            }
            i++;
        }
        write(1, "\n", 1);
    }
    else
        write(1, "\n", 1);
    return (0);
}
```