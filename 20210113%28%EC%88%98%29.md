# 학습 레포트 12일차 2021-01-13(수)
## 1.학습 날짜
> ### 2021-01-13(수)
## 2.학습 시간
> ### 14:30 ~ 17:00 (집)
## 3.학습 범위 및 주제
### | shell에서 ctrl -c 와 ctrl -d 의 차이점 |
## 4.동료 학습 방법
- 해당 없음
## 5.학습 목표
- ctrl -c 와 ctrl -d 의 차이점 알아보기
## 6.상세 학습 내용
- **실제 코딩 시간** 0시간
- **참고한 내용** [유닉스 ctrl -d](https://m.blog.naver.com/lifehelp/80104786507)

### ctrl -c와 ctrl -d
`ctrl -c` 는 주로 프로그램을 종료시키는데 자주 사용하였었다. cmd창이나, 리눅스등 터미널 창에서 코드를 작성하고 테스트를 해볼때, 무한루프에 빠지거나 비정상적인 출력이 계속될 때, ctrl -c 를 사용해서 프로그램을 끝내곤 했었다. 이번에 get next line 과제를 진행하면서 표준 입력을 받고 해당 상태를 빠져나오는데 ctrl -d를 사용하면 어떻게 되느냐는 질문이 있었다. 평소에 터미널에서 ctrl -c 로 프로그램이 안끝나거나 입력대기가 계속되면 ctrl -d를 눌러 종료를 시켰었는데 과제를 진행하면서 두 커맨드의 차이점을 알 수 있었다.

### 터미널 제어 키
`ctrl -c` 는 현재 진행중인 프로세스의 중단을 의미한다고 한다. 프로세스는 현재 실행중인 프로그램을 뜻하고 이 프로세스에 인터럽트 시그널을 날려주어 프로세스중단이 된다고 한다. `ctrl -c`와 같은 터미널 제어 키 로 `ctrl -h` 도 있는데 이것은 백스페이스라고 한다. 입력된 문자를 하나 지우는 제어 키 이다.\
`ctrl -j` 는 enter와 같은 라인피드의 이미를 가지는 제어 키 이다. 라인피드는 한라인 전진이라는 뜻을 가지고 있고 일반적으로 이 라인피드 즉, enter가 있어야 한 줄을 해석하게 된다.\
`ctrl -d` 는 라인피드 입력 전, 이 제어 키 시그널이 들어오게 되면 무조건 버퍼를 지운다고 한다. 버퍼를 지운다는것은 해당 입력대기를 건너뛴다고 이해했다. `ctrl -d` 는 원래 그냥 사용했던 **종료**와는 전혀 상관이 없었다. 그렇다면 왜 종료라고 생각하고 사용을 했던것인지 알아보았다.

### ctrl -d 는 입력 중단 신호에 가깝다.
`ctrl -d`를 입력했을 때 왜 종료한다라고 생각했었냐면 보통 입력대기를 받는 프로그램을 작성 해 보았을 때, 한번 입력을 받거나 엔터를 기준으로 입력을 구분했기 때문에 자연스럽게 프로그램 종료 시그널인 `ctrl -c`와 같은 동작처럼 보였기 때문이었다. `ctrl -d` 에 대해서 찾아보니 입력대기는 read() 함수의 표준입력으로 읽기를 하겠다는 것을 뜻한다. 과제를 진행하면서 read함수의 여러 동작을 테스트 해 보았을 때, file descriptor가 0이면 표준 입력으로 read를 하게 된다. 그리고 read함수의 리턴값은 읽은 바이트 수 이고, 정상적으로 읽었다면 0보다 큰 양수가 나와야 한다. `ctrl -j` 라인피드 시그널, 한 줄을 해석하는 단위는 엔터이고, 엔터만 입력되어도 read 함수의 반환값은 1이다. 그리고 더이상 읽을 것이 없을때 read함수가 0개의 데이터를 읽었다면 그 파일의 끝을 말하면 eof로 해석이 된다. 파일을 열었을 때 0개의 데이터라면 파일의 끝이라 할 수 있고 표준 입력으로 0개의 데이터를 입력하려면 `ctrl -d`를 입력해 그 때의 버퍼를 지우는 작업, 해당 입력을 건너뛰기를 적용하게 되어 read함수는 0개의 데이터를 받고 파일의 끝이라 생각하게 되어 더이상 read 를 하지 않게 된다. 따라서 평소 shell에서 작업을 하다가 `ctrl -c`가 작동을 안하면 `ctrl -d`를 눌러 종료 시켰다고 생각되었던 것이다.

shell에서 cat 명령어를 사용하면 사용자의 입력을 받고 입력받은 문자열을 한번 출력하는것을 본적이 많다. 이 cat 명령어는 한줄 단위로 read 함수를 시행하고 표준입력으로 입력을 대기 받는다고 생각되었다. cat 명령어를 실행하고 `ctrl -c`를 하면 명령줄에 `^C` 가 나오는것을 보면 프로세스 종료 시그널을 보내는 `ctrl -c`는 입력으로 들어가고 해당 시그널이 프로세스를 종료시켜 출력전에 프로그램이 종료된다고 보면 되고, `ctrl -d`를 입력하면 해당 입력 대기 버퍼를 지워 0 바이트를 읽은 read 함수는 파일의 끝을 알리고 해당 프로세스가 작업을 끝낸다고 이해되었다.

실제로 shell을 켜고 아무 작업도 안한 상태로 `ctrl -c`를 눌러도 shell 창이 꺼지지 않지만 `ctrl -d`를 누르면 해당 shell이 꺼지는 것을 볼 수 있다. 이것은 shell은 명령줄을 입력 대기상태이므로 내부적으로 read 함수의 표준 입력 대기를 받는 것이기 때문에 버퍼를 지우는 `ctrl -d`를 사용하면 더이상 shell에서 입력받을 것이 없다라고 해석하여 shell이 나가지는 것으로 볼 수 있을것 같다. shell에서 공백을 포함한 아무 문자나 입력 한 뒤 `ctrl -d`를 입력하면 이 때에는 shell이 나가지지 않는다 왜냐하면 입력 버퍼에 `ctrl -d`이전에 쓴 문자가 있기 때문에 read 함수는 한 개 이상의 데이터를 읽었기 때문이다.
따라서 `ctrl -d`는 종료시키는 것이 아닌 더이상 입력의 버퍼는 여기까지 입니다 라고 알려주는 시그널에 가깝다고 이해하였다.

## 7.학습 내용에 대한 개인적인 총평
get next line 과제를 통해 c언어의 입출력 함수와 쉘의 기본 작동 원리를 살짝이라도 이해하게 되는 재미있는 과정이었다. 프로그램에 따라서 `ctrl -d`는 끝내는 작업시 사용되기도 할테지만 정확히는 종료 시그널은 아니다라는것을 알게되어 재미있었다. \
본과정의 이너서클 중 앞으로 3개정도 과제를 더 끝내면 minishell 이라는 하나의 쉘을 만드는 작업이 있는것 같은데 재미있는 작업이 될것 같아 빨리 해보고 싶어졌다. 실제로 컴퓨터공학과 유닉스 시스템 프로그래밍 시간에 shell 명령어를 따라 만들어보고 쉘도 작성하는것을 본적이 있다. 
## 8.다음 학습 계획
- netwhat 과제 진행을 위해 네트워크 공부 하기
