# 학습 레포트 44일차 2021-03-05 (금)

## 1. 학습 날짜
> ### 2021-03-05 (금)

## 2. 학습 시간
> ### 21:00 ~ 23:00 (집)

## 3. 학습 범위 및 주제
### | exam ft_printf 서식지정자 처리 함수 |

## 4. 동료 학습 방법
- 해당 없음

## 5. 학습 목표
- exam ft_printf의 서식지정자 s, d, x 처리 함수 작성

## 6. 상세 학습 내용
- **실제 코딩 시간** 2시간
- **참고한 내용** 없음

### ft_str
```c
void ft_str(size_t *signal, va_list ap, int *len)
{
    char *s_buff;
    char *buff;
    
    s_buff = va_arg(ap, char *);
    if (s_buff == NULL) // 초기값 만들기
    {
        buff = ft_strdup("(null)");
    }
    else if (signal[1] == 1 && signal[2] == 0)
    {
        buff = ft_strdup("");
    }
    else
        buff = ft_strdup(s_buff);

    if (ft_strlen(buff) > signal[2] && signal[1] == 1) // 정밀도값에 따라 문자열 만들기
    {
        s_buff = malloc(signal[2] + 1);
        int i = 0;
        while (i < signal[2])
        {
            s_buff[i] = buff[i];
            i++;
        }
        s_buff[i] = '\0';
    }
    else
        s_buff = ft_strdup(buff);
    free(buff);

    if (signal[0] > ft_strlen(s_buff)) // 너비값에 따라 문자열 만들기
    {
        buff = malloc(signal[0] + 1);
        int i = 0;
        while (i < signal[0])
        {
            buff[i] = ' ';
            i++;
        }
        i = 0;
        while (i < ft_strlen(s_buff))
        {
            buff[signal[0] - ft_strlen(s_buff) + i] = s_buff[i];
            i++;
        }
    }
    else
        buff = ft_strdup(s_buff);
    free(s_buff);
    
    write(1, buff, ft_strlen(buff));
    *len += ft_strlen(buff);
    free(buff);
}
```
위 코드는 서식지정자 s를 만나면 호출되는 함수이다.
1. 가변인자로부터 문자열을 s_buff에 받아서 초기 buff 값을 설정한다. 가변인자의 주소가 NULL 이면 (null) 문자열을 복사하고, 정밀도가 설정되었지만 정밀도 값이 0이면 빈 문자열을 복사한다. 그 이외에는 가변인자의 문자열을 복사한다.
2. 원본 문자열을 정밀도에 따라 문자열을 자르거나 그냥 복사한다.
3. 정밀도에 따라 만들어진 문자열을 너비만큼 늘려주거나 그냥 복사한다.

### s와 d, x의 차이점
서식지정자 d, x도 위 세번의 순서를 동일하게 사용하였고, d, x의 경우 정수와 부호없는 16진수 정수이므로 가변인자에서 받아온 정수를 문자열로 만드는 함수가 추가되는 것의 차이점이 있다.

### ft_d
```c
ft_d(size_t *signal, va_list ap, int *len)
{
    char *d_buff;
    char *buff;
    int num;
    
    num = va_list(ap, int);
    if (signal[1] == 1 && signal[2] == 0 && num == 0)
        d_buff = ft_strdup("");
    else
        d_buff = ft_itoa(num);
    
    if (signal[1] == 1 && signal[2] > ft_strlen(d_buff))
    {
        if (num < 0)
            signal[2]++;
        buff = malloc(signal[2] + 1);
        int i = 0;
        while (i < signal[2])
        {
            buff[i] = '0';
            i++;
        }
        buff[i] = '\0';
        if (num < 0)
        {
            buff[0] = '-';
            d_buff[0] = '0';
        }
        i = 0;
        while (i < ft_strlen(d_buff))
        {
            buff[signal[2] - ft_strlen(d_buff) + i] = d_buff[i];
            i++;
        }
    }
    else
        buff = ft_strdup(d_buff);
    free(d_buff);
    
    if (signal[0] > ft_strlen(buff))
    {
        d_buff = malloc(signal[0] + 1);
        int i = 0;
        while (i < signal[0])
        {
            d_buff[i] = ' ';
            i++;
        }
        d_buff[i] = '\0';
        i = 0;
        while (i < ft_strlen(buff))
        {
            d_buff[signal[0] - ft_strlen(buff) + i] = buff[i];
            i++;
        }
    }
    else
        d_buff = ft_strdup(buff);
    free(buff);
    
    write(1, d_buff, ft_strlen(d_buff));
    *len += ft_strlen(d_buff);
    free(d_buff);
}
```


## 7. 학습 내용에 대한 개인적인 총평

## 8. 다음 학습 계획
- exam get_next_line 작성