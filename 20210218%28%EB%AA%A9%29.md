# 학습 레포트 34일차 2021-02-18(목)
## 1.학습 날짜
> ### 2021-02-18(목)

## 2.학습 시간
> ### 22:00 ~ 24:00(집)

## 3.학습 범위 및 주제
### | file descriptor, get_next_line |

## 4.동료 학습 방법
- 온라인 - dongilee님, seshin님, hyeonpar님

## 5.학습 목표
- `open` 할 수 있는 파일의 갯수

## 6.상세 학습 내용
- **실제 코딩 시간** 1시간
- **참고한 내용** [open , create](http://forum.falinux.com/zbxe/index.php?document_srl=408459&mid=C_LIB)

### 질문. GNL에서 열 수 있는 fd 최대값을 유닉스 기본값(256)으로 설정 해 두었는데, 테스트 해 볼 수 있을까
dongilee 님 께서 질문을 해주셨는데 GNL 함수에서 `open` 했던 fd의 `read` 쓰레드를 잃지 않고 다른 파일을 열고 할 때, 포인터 배열을 사용해 256 개의 배열을 임의로 설정했다. 256은 유닉스 명령어 `ulimit -a` 를 통해 file descriptor의 기본 값으로 나온 것을 설정한 것이다. 하지만 seshin님의 개인 맥북에서 해당 명령어를 치면, 2560이라고 한다. 그렇다면 GNL 함수에서 fd의 최대값을 지정해 주는것은 맞는 것인가.

나는 GNL 함수를 작성 할 때, VNC를 통해서 작성을 했었고, 현재는 virtual box에서 코드를 작성하는 중이다. seshin님의 개인 맥북에서 처럼 기본 file descriptor 값이 환경마다 다를 수 있다는 것을 알게 되었고, 그렇다면 실제로 열수 있는 파일의 갯수를 세어 보면 GNL 함수에서 포인터 배열로 fd를 어떻게 관리해도 되는지 알 수 있을것 같았다.

### 나의 경우
나는 먼저 질문을 받았을 때 테스트 하기를 조언했고, `ulimit -aH`를 통해 시스템 최대값을 출력해 보면 file decriptor의 경우 unlimited로 제한이 없다고 나오는 것을 통해 아마 시스템에서 기본값을 넘어서는 경우 자동으로 파일을 열며 그때 마다 최대값이 유동적으로 바뀌지 않을까 생각을 했었다.

### seshin 님의 겨우
seshin님 께서 예상하기로는 설정된 fd기본값을 넘어서게 되면 open이 되지 않고 -1을 반환 할 것 같다고 하셨다.

### 코드 작성
코드를 작성해 보려고 생각해보니 파일을 300개 정도 직접 생성하기는 귀찮고 하나의 파일을 복사해 나가며 작성하는 것도 스크립트를 통해 작성하면 가능하지만 이것도 프로그램을 작성하기 난해할 것 같아 그냥 파일을 하나씩 만들고 오픈 해 나가며 그때의 fd 값을 출력해 보고, `open` 실패는 어디서 나타날 지 비교하기로 하였다.

1. 파일을 새로 생성한다.
2. 새로 만든 파일을 open 한다.
3. open된 fd값을 출력 해 본다.
4. 만약 open 실패 시 fd값은 -1이 되며, 반복을 중지한다.
5. 만약 계속 open한다면 어디까지 오픈될지 값을 바꿔보며 프로그램을 실행 한다.

위 5가지 프로세스에 따라 파일을 만들고 오픈하고 fd를 출력하고 반복을 할 수 있는 코드를 작성 해 보았다.

```c
#include <stdio.h>
#include <fcntl.h>
#include "libft.h"

int main()
{
    int fd;
    int i;
    char *file;
    char *file_n;
    
    fd = 0;
    i = 0;
    while (fd >= 0 && fd < 410)
    {
        file_n = ft_itoa(i);
        i++;
        file = ft_strjoin("./files/file_", file_n);
        free(file_n);
        file_n = NULL;
        
        printf("file name : %s\n || ", file);
        fd = open(file, O_CREAT, 0777);
        printf("fd : %d\n", fd);
        free(file);
        file = NULL;
    }
    return (0);
}
```

- file_n 변수는 ft_itoa 함수를 이용해 숫자를 문자열로 만들어 파일의 순서번호를 나타낼 수 있도록 하였다.
- file은 files 디렉터리 안에 file\_(i) 값으로 저장할 수 있도록 경로와 file_n을 strjoin 해서 값을 가지도록 하였다. 경로 명을 붙여준 이유는 `open` 할 때 해당 경로를 포함해 지정해 주기 위해서 이다.
- ft_itoa 함수에서 동적할당을 사용했기 때문에 사용이 끝난 feil_n 변수는 free 함수로 할당 해제를 해준다.
- open 함수를 통해 `./files/` 디렉터리 안에 file_0 번 부터 파일을 생성하고 열도록 하였다. O_CREAT 는 파일을 생성하고, mode 인자가 추가되어야 하므로 777 모드를 주었다. `0777` 로 작성해 준 이유는 일반적으로 숫자는 10진수로 들어가게 되는데 파일의 권한은 8진수를 세자리를 사용하므로 숫자 앞에 0을 붙여 8진수로 나타냄을 알리기 위해서 이다. 마찬가지로 0x를 붙여주면 16진수로 사용된다.
- file name 과 fd 값을 출력해보며 fd 값이 0보다 크거나 같고, fd 값이 410보다 작으면 반복을 계속 한다.

위 코드를 실행 하면 결과는 다음고 같다.
```
file name : ./files/file_0 || fd : 3
file name : ./files/file_1 || fd : 4
file name : ./files/file_2 || fd : 5
file name : ./files/file_3 || fd : 6

...

file name : ./files/file_250 || fd : 253
file name : ./files/file_251 || fd : 254
file name : ./files/file_252 || fd : 255
file name : ./files/file_253 || fd : -1
```
파일을 열게되면 fd값은 3부터 시작하는데 이유는 0, 1, 2는 표준 입력, 표준 출력, 표준 에러로 기본적으로 지정된 값이기 때문에 파일을 open 한 값은 3부터 시작함을 알 수 있다.\
반복문을 통해 계속 파일을 close 하지 않고 open 하면 fd값의 변화를 볼 수 있었는데 fd값이 255를 넘어서면 -1을 반환하는 것을 알 수 있었다.\
`ulimit -a` 명령어로 확인한 file descriptor 의 갯수 256개와 맞는 숫자였다. (0 ~ 255)\

### 결과
실제로 파일을 만들고 open 하며 fd값을 출력 해본 결과 시스템 기본값을 넘어서면 open 함수는 -1을 반환하는것을 알 수 있었다. 더이상 파일을 open 할 수 없는 것이다. seshin 님의 예상이 맞았다는 것을 실제 결과를 통해 알 수 있었다.\
나는 시스템의 최대값을 제한이 없으므로 메모리의 제한이 생기기 전까지는 open을 계속해 나갈 것이라고 생각을 했었는데 실제 시스템에서는 기본값을 기준으로 관리자가 open 할 수 있는 값을 바꾸지 않는 이상 제한된 파일의 갯수를 여는 것을 알 수 있는 실험이었다.

## 7.학습 내용에 대한 개인적인 총평
GNL 함수를 작성하면서 다중 파일을 열게 하기위해 open 할 수 있는 fd 기본값과 최대값을 찾아보기는 하였으나 이것은 최대값이 제한이 없으므로 반쪽짜리 코드라고 생각을 하기도 했고, 슬랙을 찾아보아도 배열처럼 갯수를 지정해 두는 것은 완벽한 것이 아닐까 하는 의문을 가진 분들이 계신것을 알 수 있었다.\
실제로 열어보는것을 생각해 보지 못했었는데 dongilee 님께서 질문을 마침 주셔서 생각해보고 코드 작성도 어려울 것 같지 않아 직접 테스트를 해보게 되었다. 검색하고 코드를 작성하고 과제를 제출하는것도 블랙홀에 빠지지 않기 위해 최소한으로 해야 하는 것이지만, 이렇게 다른분들의 질문을 받고 질문을 하는 과정에서 내가 생각하지 못한 테스트방법이나 의문사항을 해결해 나가는 것이 동료학습이 가능한 42 시스템의 중요한 부분이라는 점이 다시 느껴졌다. 혼자서는 생각하지 못하는 부분도 분명 있기 때문에 동료분들과 함께 하는것, 협업이 정말 중요하다는 것을 다시 느낄 수 있었다.

## 8.다음 학습 계획
- printf 테스트