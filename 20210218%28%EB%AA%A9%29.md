# 학습 레포트 34일차 2021-02-18(목)
## 1.학습 날짜
> ### 2021-02-18(목)

## 2.학습 시간
> ### 22:00 ~ 24:00(집)

## 3.학습 범위 및 주제
### | file descriptor, get_next_line |

## 4.동료 학습 방법
- 온라인 - dongilee님, seshin님, hyeonpar님

## 5.학습 목표
- `open` 할 수 있는 파일의 갯수

## 6.상세 학습 내용
- **실제 코딩 시간** 1시간
- **참고한 내용** 

### 질문. GNL에서 열 수 있는 fd 최대값을 유닉스 기본값(256)으로 설정 해 두었는데, 테스트 해 볼 수 있을까
dongilee 님 께서 질문을 해주셨는데 GNL 함수에서 `open` 했던 fd의 `read` 쓰레드를 잃지 않고 다른 파일을 열고 할 때, 포인터 배열을 사용해 256 개의 배열을 임의로 설정했다. 256은 유닉스 명령어 `ulimit -a` 를 통해 file descriptor의 기본 값으로 나온 것을 설정한 것이다. 하지만 seshin님의 개인 맥북에서 해당 명령어를 치면, 2560이라고 한다. 그렇다면 GNL 함수에서 fd의 최대값을 지정해 주는것은 맞는 것인가.

나는 GNL 함수를 작성 할 때, VNC를 통해서 작성을 했었고, 현재는 virtual box에서 코드를 작성하는 중이다. seshin님의 개인 맥북에서 처럼 기본 file descriptor 값이 환경마다 다를 수 있다는 것을 알게 되었고, 그렇다면 실제로 열수 있는 파일의 갯수를 세어 보면 GNL 함수에서 포인터 배열로 fd를 어떻게 관리해도 되는지 알 수 있을것 같았다.

### 나의 경우
나는 먼저 질문을 받았을 때 테스트 하기를 조언했고, `ulimit -aH`를 통해 시스템 최대값을 출력해 보면 file decriptor의 경우 unlimited로 제한이 없다고 나오는 것을 통해 아마 시스템에서 기본값을 넘어서는 경우 자동으로 파일을 열며 그때 마다 최대값이 유동적으로 바뀌지 않을까 생각을 했었다.

### seshin 님의 겨우
seshin님 께서 예상하기로는 설정된 fd기본값을 넘어서게 되면 open이 되지 않고 -1을 반환 할 것 같다고 하셨다.

### 코드 작성
코드를 작성해 보려고 생각해보니 파일을 300개 정도 직접 생성하기는 귀찮고 하나의 파일을 복사해 나가며 작성하는 것도 스크립트를 통해 작성하면 가능하지만 이것도 프로그램을 작성하기 난해할 것 같아 그냥 파일을 하나씩 만들고 오픈 해 나가며 그때의 fd 값을 출력해 보고, `open` 실패는 어디서 나타날 지 비교하기로 하였다.

1. 파일을 새로 생성한다.
2. 새로 만든 파일을 open 한다.
3. open된 fd값을 출력 해 본다.
4. 만약 open 실패 시 fd값은 -1이 되며, 반복을 중지한다.
5. 만약 계속 open한다면 어디까지 오픈될지 값을 바꿔보며 프로그램을 실행 한다.

위 5가지 프로세스에 따라 파일을 만들고 오픈하고 fd를 출력하고 반복을 할 수 있는 코드를 작성 해 보았다.

```c
#include <stdio.h>
#include <fcntl.h>
#include "libft.h"

int main()
{
    int fd;
    int i;
    char *file;
    char *file_n;
    
    fd = 0;
    i = 0;
    while (fd >= 0 && fd < 410)
    {
        file_n = ft_itoa(i);
        i++;
        file = ft_strjoin("./files/file_", file_n);
        free(file_n);
        file_n = NULL;
        
        printf("file name : %s\n || ", file);
        fd = open(file, O_CREAT, 0777);
        printf("fd : %d\n", fd);
        free(file);
        file = NULL;
    }
    return (0);
}
```

- file_n 변수는 ft_itoa 함수를 이용해 숫자를 문자열로 만들어 파일의 순서번호를 나타낼 수 있도록 하였다.
- file은 files 디렉터리 안에 file\_(i) 값으로 저장할 수 있도록 경로와 file_n을 strjoin 해서 값을 가지도록 하였다. 경로 명을 붙여준 이유는 `open` 할 때 해당 경로를 포함해 지정해 주기 위해서 이다.
- ft_itoa 함수에서 동적할당을 사용했기 때문에 사용이 끝난 feil_n 변수는 free 함수로 할당 해제를 해준다.
- open 함수를 통해 `./files/` 디렉터리 안에 file_0 번 부터 파일을 생성하고 열도록 하였다. O_CREAT 는 파일을 생성하고, mode 인자가 추가되어야 하므로 777 모드를 주었다. `0777` 로 작성해 준 이유는 일반적으로 숫자는 10진수로 들어가게 되는데 파일의 권한은 8진수를 세자리를 사용하므로 숫자 앞에 0을 붙여 8진수로 나타냄을 알리기 위해서 이다. 마찬가지로 0x를 붙여주면 16진수로 사용된다.
- file name 과 fd 값을 출력해보며 fd 값이 0보다 크거나 같고, fd 값이 410보다 작으면 반복을 계속 한다.

위 코드를 실행 하면 결과는 다음고 같다.
```
file name : ./files/file_0 || fd : 3
file name : ./files/file_1 || fd : 4
file name : ./files/file_2 || fd : 5
file name : ./files/file_3 || fd : 6

...

file name : ./files/file_250 || fd : 253
file name : ./files/file_251 || fd : 254
file name : ./files/file_252 || fd : 255
file name : ./files/file_253 || fd : -1
```
