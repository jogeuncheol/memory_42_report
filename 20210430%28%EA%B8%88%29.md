# 학습 레포트 79일차 2021-04-30 (금)

## 1. 학습 날짜
> ### 2021-04-30 (금)

## 2. 학습 시간
> ### 12:00 ~ 17:30 (금)

## 3. 학습 범위 및 주제
### | cub3D 벽 텍스처 수정, 어안효과 수정 |

## 4. 동료 학습 방법
- seshin 님

## 5. 학습 목표
- cub3D 벽에 텍스처 입히기 코드 수정, 어안효과 추가 수정

## 6. 상세 학습 내용
- **실제 코딩 시간** 5시간
- **참고한 내용** 없음

### 코드 수정하기

seshin님께 문제를 보여드리고 코드를 수정했다.
```c
while (h > 0) // && H > pixel_count)
	{
		h--;
		x = (z++) * ((float)32 / (H));
		color = param->texture[x][y];

		if (j - h < 0 || j + h > (WINDOW_HEIGHT - 1))
			continue;

		int top = (WINDOW_HEIGHT - h) / 2;
		int bottom = h + top;

		param->half.data[width_inc + (int)(floor(WINDOW_HEIGHT / 2) - h) * WINDOW_WIDTH] = color;
/*		if (top < bottom)
			param->half.data[width_inc + (top++) * WINDOW_WIDTH] = color;
		else
			break;*/

		color = param->texture[31 - x][y];
		param->half.data[width_inc + (int)(floor(WINDOW_HEIGHT / 2) + h) * WINDOW_WIDTH] = color;
	}
```

텍스처의 x값을 정하는데 z * (32 / h) 수식을 사용했는데, z 변수는 0부터 벽의 크기만큼 증가를 한다. 이 값에 `32 / h`를 곱하면 이전에 작성한 pixel_count 와 같은 작동을 하게 된다. pixel_count로 한 픽셀을 몇번 그릴지 정했다면 (32 / h) 가 그 역할을 하게 된다. 32를 실수로 캐스팅 해준 이유는 나머지 값도 유지해 z 증가값을 곱해주기 위해서이다. 만약 `32 / h`가 0.35 라면 z가 0, 1, 2일때는 0이되고, 3, 4, 5에서 1이 된다. 이렇게 한 픽셀을 세번씩 그려줄 수 있다.

```c
color = param->texture[31 - x][y];
```
위의 절반 벽을 세울때는 `texture[x][y]`값을 사용하면 되지만 벽의 아래를 그릴때는 `texture[31 - x][y]`값을 사용한다. x는 0부터 증가하게 되고 벽을 그리는 코드는 중앙에서 위아래 대칭으로 픽셀을 그리므로 텍스처 사이즈 32 에서 x를 빼면 밑의 텍스처의 값을 사용할 수 있다.

```c
    int top = (WINDOW_HEIGHT - h) / 2;
    int bottom = h + top;
    if (top < bottom)
        param->half.data[width_inc + (top++) * WINDOW_WIDTH] = color;
    else
        break;
```
위 방법은 seshin님께서 설명해주신 것을 토대로 벽을 그릴 때 top 지점에서 bottom 좌표를 구한 뒤, 한번에 하나씩 값을 사용하는 코드이다. 벽의 높이를 알고 있으면 윈도우 높이 - 벽의 높이의 절반이 화면에서 벽을 그릴 첫번째 위치이다. bottom 좌표는 첫번째 위치에 벽의 높이를 더하면 된다. 벽을 그릴때 top의 좌표에서부터 값을 증가시키면서 bottom까지 그리게 되면 벽이 완성이 된다.

### 어안효과 추가 수정

먼저 작성했던 어안효과를 보정할 때 사용한 방법은 벽까지의 거리에 cos 값을 곱해 거리를 보정해 주었었다. 그러나 실제로 텍스쳐를 사용해보면 중앙에서 이미지가 늘어져 보이는 것을 볼 수 있었다. 어안효과를 보정하지 않은 상태와 보정한 상태를 비교해 보니 조금 더 먼 거리에 있는 것을 앞으로 가져올 때, 각 픽셀간 간격까지 보정이 되지 않아 주변부보다 중앙의 각도 비율이 다르다는 것을 알 수 있었다.

이전 코드
```c
	while (FOV < param->degree + 30)
	{
		if (i % (TILE_SIZE / 16) == 0) // 연산량 줄이기, 계단현상 높아짐
		{
			DDA_grid_find_coord(param); // draw FOV ray
			grid_find_coord(param, FOV); // calculate grid coord
			count++;
		}
		screen_pixel_put(param, i, FOV); // draw wall
		FOV = FOV + 0.125;
		i++;
	}
```

수정 코드
```c
    while (i < WINDOW_WIDTH / 2)
	{
		float seta = atan((WINDOW_WIDTH / 2 - i) / ((WINDOW_WIDTH / 2) / tan(30 * M_PI / 180)));
		float degree = param->degree - (seta * 180 / M_PI);
		float degree2 = param->degree + (seta * 180 / M_PI);
		grid_find_coord(param, degree);
        DDA_grid_find_coord(param);
		screen_pixel_put(param, i, degree);
		grid_find_coord(param, degree2);
		DDA_grid_find_coord(param);
		screen_pixel_put(param, WINDOW_WIDTH - 1 - i, degree2);
		i++;
	}
```

위 코드는 어안효과를 보정하는 계산을 수정한 것은 아니다. 어안효과를 보정하는 방법에는 문제가 없었다. 문제는 시야각 FOV의 값을 윈도우의 너비에 맞춰 각을 증가시켜 일정하게 벽에 광선을 쏘았기 때문이었다. 일정한 각도로 광선을 쏴 벽에 맞은 좌표를 벽으로 그린다. 문제가 없는 방법이다. 하지만 실제로 광선을 따라가 보면, 각도는 일정하지만 벽에 닿은 광선의 좌표끼리의 거리는 일정하지 않다. 처음 쏜 광선과 두번째 광선, 두번째 광선과 세번쨰 광선의 거리가 다르게 나타난것이다. 따라서 주변부와 중앙부에서 이미지가 찌그러져 보이는 현상이 나타났던 것이다.

이전 코드를 보면 FOV 값을 사용해 0.125 = `60 / 480` 를 광선을 쏠 각도를 지정해 줬다면, 수정 코드에서는 쏠 광선의 각도를 재계산을 하고, 광선을 쏴서 벽에 닿는 좌표를 계산한다. 즉, 벽에 닿은 좌표들의 거리비율을 일정하게 만들어주기 위해서 각도를 계산하고 광선을 쏘는것이다.

이전에는 각도가 일정했다면, 수정하고는 각도는 주변부에서 크고, 중앙에 올수록 작아진다.\
각도를 새로 구해주기 위해 기준이 될 각도가 필요한데 이것은 FOV의 절반 나는 30도로 정했다. FOV값을 60도라고 했을때 좌30, 우30 으로 나눌 수 있기 때문이다. 또한 tan를 사용하면 일정한 거리를 사용해 일정한 벽좌표와 벽까지의 거리를 사용할 수 있다. 어안효과 수정을 위해 벽에 닿은 좌표들은 서로 일정한 거리로 나뉘어야 한다. 나는 윈도우 너비를 이전부터 사용했기 때문에 WINDOW_WIDTH를 사용하기로 했다.

시야각에서 가장 외각 광선은 좌로 30도 우로 30도에 해당하는 광선이고, 그때, 플레이어로부터 벽으로 수직으로 쏜 광선과 30도를 이루는 광선이 만드는 삼각형은 각도가 30도인 직각삼각형을 만들 수 있다. `tan30 = (WINDOW_WIDTH / 2) / dst` 이다. dst는 플레이어로부터 벽까지 수직의 거리이다. 그렇다면 dst는 어떻게 구할까.

dst는 광선을 쏜 벽까지의 거리를 사용할 수도 있을 것이다. 하지만 삼각형을 이용해 보면 `tan30 = (WINDOW_WIDTH / 2) / dst`, `dst = (WINDOW_WIDTH / 2) / tan30`가 된다. 이것은 고정된 값으로 사용이 가능하다. 왜냐하면 우리가 이러한 식을 사용해 구하려는 것이 거리가아닌 각도이다. 각도는 어떻게 구할 것인가. 각도는 탄젠트의 역을 이용하면 된다. `math.h`에는 삼각함수의 유용한 함수들이 있기때문에 따로 계산식을 작성할 필요가 없었다.

`30 = atan((WINDOW_WIDTH / 2) / dst)`라는 것이 성립한다. 즉 우리가 구하는 seta 각도는 `atan((WINDOW_WIDTH / 2) / ((WINDOW_WIDTH / 2) / tan30))`를 이용해 구할 수 있다. 실제로 첫번째 광선의 각도는 위 식으로 -30도가 구해진다. 여기서 벽에 닿은 좌표끼리는 거리가 일정해야하고 나는 윈도우의 너비만큼 광선을 쏠 것이기 때문에 0부터 479까지 광선을 쏠 것이다. 즉, 일정한 거리는 1 이된다. 결과적으로 480개의 광선들 사이의 거리는 1로 일정하게 된다는 것을 뜻한다.

따라서 결과적으로 `seta = atan(((WINDOW_WIDTH / 2) - i) / ((WINDOW_WIDTH / 2) / tan(30))` 이 사용된다. 이렇게 찾은 각도는 플레이어를 기준으로 좌 우로 대칭적으로 사용이 가능하므로 벽을 그리는 함수인 screen_pixel_put 함수를 두번 사용하는데 너비 인덱스로 0부터 239까지의 값과 479부터 240까지의 값을 사용하게 해서 화면상의 좌우 벽을 그리게 했다.

## 7. 학습 내용에 대한 개인적인 총평
코드를 수정하면서 움직이면 텍스처가 아래로 내려가거나, 위 절반에 텍스처를 전부 그리고 아래 절반에도 전부 그리는 등 다양하게 문제를 보았었다. top과 bottom 변수로 벽을 한번에 쭉 그리는 방법도 사용해 보았는데 설명을 들은 방법으로 그리려고 하니 내가 작성한 코드에서 잘 작동하지 않아서 원래대로 화면의 중앙에서 위 아래로 그리는 방식으로 수정을 했다. 어안효과를 수정하기 위해서 일정한 각도를 사용했던 것을 일정한 거리로 수정하기 위해 seshin님께 도움을 많이 받았다. 덕분에 수정을 할 수 있게 되었다. 오랜만에 클러스터에 나가 동료분과 코드를 함께 보며 작업을 하니 피신때 생각도 나고 재미있었다.

## 8. 다음 학습 계획
- cub3D 공부