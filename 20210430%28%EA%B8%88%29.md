# 학습 레포트 79일차 2021-04-30 (금)

## 1. 학습 날짜
> ### 2021-04-30 (금)

## 2. 학습 시간
> ### 12:00 ~ 17:30 (금)

## 3. 학습 범위 및 주제
### | cub3D 벽 텍스처 수정, 어안효과 수정 |

## 4. 동료 학습 방법
- seshin 님

## 5. 학습 목표
- cub3D 벽에 텍스처 입히기 코드 수정, 어안효과 추가 수정

## 6. 상세 학습 내용
- **실제 코딩 시간** 5시간
- **참고한 내용** 없음

### 코드 수정하기

seshin님께 문제를 보여드리고 코드를 수정했다.
```c
while (h > 0) // && H > pixel_count)
	{
		h--;
		x = (z++) * ((float)32 / (H));
		color = param->texture[x][y];

		if (j - h < 0 || j + h > (WINDOW_HEIGHT - 1))
			continue;

		int top = (WINDOW_HEIGHT - h) / 2;
		int bottom = h + top;

		param->half.data[width_inc + (int)(floor(WINDOW_HEIGHT / 2) - h) * WINDOW_WIDTH] = color;
/*		if (top < bottom)
			param->half.data[width_inc + (top++) * WINDOW_WIDTH] = color;
		else
			break;*/

		color = param->texture[31 - x][y];
		param->half.data[width_inc + (int)(floor(WINDOW_HEIGHT / 2) + h) * WINDOW_WIDTH] = color;
	}
```

텍스처의 x값을 정하는데 z * (32 / h) 수식을 사용했는데, z 변수는 0부터 벽의 크기만큼 증가를 한다. 이 값에 `32 / h`를 곱하면 이전에 작성한 pixel_count 와 같은 작동을 하게 된다. pixel_count로 한 픽셀을 몇번 그릴지 정했다면 (32 / h) 가 그 역할을 하게 된다. 32를 실수로 캐스팅 해준 이유는 나머지 값도 유지해 z 증가값을 곱해주기 위해서이다. 만약 `32 / h`가 0.35 라면 z가 0, 1, 2일때는 0이되고, 3, 4, 5에서 1이 된다. 이렇게 한 픽셀을 세번씩 그려줄 수 있다.

```c
color = param->texture[31 - x][y];
```
위의 절반 벽을 세울때는 `texture[x][y]`값을 사용하면 되지만 벽의 아래를 그릴때는 `texture[31 - x][y]`값을 사용한다. x는 0부터 증가하게 되고 벽을 그리는 코드는 중앙에서 위아래 대칭으로 픽셀을 그리므로 텍스처 사이즈 32 에서 x를 빼면 밑의 텍스처의 값을 사용할 수 있다.

```c
    int top = (WINDOW_HEIGHT - h) / 2;
    int bottom = h + top;
    if (top < bottom)
        param->half.data[width_inc + (top++) * WINDOW_WIDTH] = color;
    else
        break;
```
위 방법은 seshin님께서 설명해주신 것을 토대로 벽을 그릴 때 top 지점에서 bottom 좌표를 구한 뒤, 한번에 하나씩 값을 사용하는 코드이다. 벽의 높이를 알고 있으면 윈도우 높이 - 벽의 높이의 절반이 화면에서 벽을 그릴 첫번째 위치이다. bottom 좌표는 첫번째 위치에 벽의 높이를 더하면 된다. 벽을 그릴때 top의 좌표에서부터 값을 증가시키면서 bottom까지 그리게 되면 벽이 완성이 된다.

### 어안효과 추가 수정

먼저 작성했던 어안효과를 보정할 때 사용한 방법은 벽까지의 거리에 cos 값을 곱해 거리를 보정해 주었었다. 그러나 실제로 텍스쳐를 사용해보면 중앙에서 이미지가 늘어져 보이는 것을 볼 수 있었다. 어안효과를 보정하지 않은 상태와 보정한 상태를 비교해 보니 조금 더 먼 거리에 있는 것을 앞으로 가져올 때, 각 픽셀간 간격까지 보정이 되지 않아 주변부보다 중앙의 각도 비율이 다르다는 것을 알 수 있었다.

```c
	while (FOV < param->degree + 30)
	{
		if (i % (TILE_SIZE / 16) == 0) // 연산량 줄이기, 계단현상 높아짐
		{
			DDA_grid_find_coord(param); // draw FOV ray
			grid_find_coord(param, FOV); // calculate grid coord
			count++;
		}
		screen_pixel_put(param, i, FOV); // draw wall
		FOV = FOV + 0.125;
		i++;
	}
```
이전 코드

```c
    while (i < WINDOW_WIDTH / 2)
	{
		float seta = atan((WINDOW_WIDTH / 2 - i) / ((WINDOW_WIDTH / 2) / tan(30 * M_PI / 180)));
		float degree = param->degree - (seta * 180 / M_PI);
		float degree2 = param->degree + (seta * 180 / M_PI);
		grid_find_coord(param, degree);
        DDA_grid_find_coord(param);
		screen_pixel_put(param, i, degree);
		grid_find_coord(param, degree2);
		DDA_grid_find_coord(param);
		screen_pixel_put(param, WINDOW_WIDTH - 1 - i, degree2);
		i++;
	}
```
수정 코드


## 7. 학습 내용에 대한 개인적인 총평
코드를 수정하면서 움직이면 텍스처가 아래로 내려가거나, 위 절반에 텍스처를 전부 그리고 아래 절반에도 전부 그리는 등 다양하게 문제를 보았었다. top과 bottom 변수로 벽을 한번에 쭉 그리는 방법도 사용해 보았는데 설명을 들은 방법으로 그리려고 하니 내가 작성한 코드에서 잘 작동하지 않아서 원래대로 화면의 중앙에서 위 아래로 그리는 방식으로 수정을 했다. 오랜만에 클러스터에 나가 동료분과 코드를 함께 보며 작업을 하니 피신때 생각도 나고 재미있었다.

## 8. 다음 학습 계획
- cub3D 공부