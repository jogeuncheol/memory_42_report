# 학습 레포트 7일차 2021-01-05(화)
## 1.학습 날짜
> ### 2021-01-05(화)
## 2.학습 시간
> ### 22:05 ~ 23:55 (집)
## 3.학습 범위 및 주제
### |ft_split 함수에서 free를 해주는 이유, lstaddback 함수의 이중포인터 인자|
## 4.동료 학습 방법
- 온라인 - seshin, dongilee, hyeonpar 님과 토론
## 5.학습 목표
- ft_split 함수에서 free를 해주는 이유 알아보기.
- lstaddback 함수의 인자는 왜 이중 포인터인가.
## 6.상세 학습 내용
- **코딩에 사용된 시간** 약 1시간
- **참고한 내용** [동적할당 함수](https://twinw.tistory.com/52), [free 함수](https://modoocode.com/244)

### free 함수
- **형식**
`void free(void *ptr)`
- **반환 값** 없다.
- **설명**\
메모리를 해제한다.\
`free` 는 포인터 변수에 메모리를 동적 할당해주는 함수 `malloc`, `calloc`, `realloc` 등 을 사용해 할당된 메모리를 해제하는 함수로 나중에 다시 사용될 수 있게 해준다.

### ft_split 함수에서 free 함수를 사용하는 경우.
왜 `split`함수에서는 `free`를 사용해서 메모리 해제를 해주어야 하는지 seshin 님께서 질문을 올려주셨다.\
libft 과제를 하다보면 `split` 이외에 `strdup`, `strjoin`, `substr` 등 함수들도 동적할당을 해서 함수를 작성하게 되는데 왜 `split` 함수에서 `free` 함수의 사용이 가능하고, 왜 사용해야 하는지 질문을 해주셨다.\
`split` 함수 작성 코드 중 일부를 가져왔다.
```c
if (!(ptr[i] = (char *)malloc(sizeof(char) * (word + 1))))
{
    ft_make_free(ptr);
    free(ptr);
    return (NULL);
}
```
처음 `split`함수를 작성 할 때에는 free를 해주지 않았었는데 슬랙에서 함수에 대해 검색하면서 알게 된 것이 할당에 실패하면 free를 해주어야 한다고 글이 많이 있었다.

`split` 함수와 `dup`, `join`, `substr` 함수들의 차이점은 함수 내에서 동적할당을 몇번 하는지 횟수의 차이점이 있었다. 다른 함수들은 함수 내에서 단일 문자열을 만들기 위한 동적할당을 위해 `malloc` 을 사용했다. 하지만 `split` 함수는 함수 내에서 포인터의 배열을 만들어 나눈 문자열들을 각각 저장하도록 동적할당을 해주어야 한다. 따라서 동적 할당을 할 때, 이전의 할당된 메모리 공간이 존재하고, 만약 중간에 메모리 할당에 실패 하면 이전까지 할당된 공간을 해제 해주어야 메모리의 누수가 없을것이다. 물론 함수 외부에서 할당된 메모리 공간을 해제 해줄 수 있다. 하지만 프로그래머도 사람이고, 프로그램의 코드가 길어지고, 분업이 되다보면 다른 공간에서 해제를 해주는것보다 담당 한 함수에서 오류가 있다면 그곳에서 직접 메모리 해제를 해주는것이 가장 예외상황을 줄이고 오류가 없는 프로그램을 작성하는 것이라고 생각하였다.

### free 함수를 사용하고 해당 메모리는 어떻게 되는가
과제의 동료평가를 받으면서 해당 카뎃분이 알려주신 것인데, free를 해준 후 NULL을 넣어주면 더 좋다고 하셨다. 이유로는 나중에 다시 다른 곳에서 해당 메모리를 사용하게 되었을 때, 원하지 않는 값이 존재 할 수 있기 때문에 NULL을 넣어주어야 한다고 하셨다.\
이 과정에 대해서도 질문을 해주셨다.\
나는 단순하게 생각해서 당연히 해주면 좋은 것이라 생각을 했었는데, 질문을 주셔서 생각해보니 이상했다.\
이미 메모리를 해제했는데 왜 NULL 을 넣어준다는 것일까. 메모리를 해제하면 해당 변수에 할당되었던 주소와의 연결이 사라진다라고 생각하고 있었다. 물론 `free` 이전에 넣어준 값은 그대로 있을것이라 생각했다. 그래서 간단하게 코드를 작성해서 작동 방식을 보며 토론을 이어갔다.
- malloc 주소와 free 이후의 변화 코드
```c
int *a;
printf("a addr : %p\n", &a);
a = malloc(5);
a[0] = 1;
a[1] = 2;
...
printf("malloc\n");
printf("a addr : %p\n", &a);
printf("a malc : %p\n", a);
printf("a vals : %p\n", a[0]);

printf("free\n");
free(a);
printf("a addr : %p\n", &a);
printf("a malc : %p\n", a);
printf("a vals : %p\n", a[0]);
```
해당 코드는 포인터 변수 a를 만들고 해당 변수의 주소와, 동적할당한 포인터 a에 들어있는 주소값, 그리고 할당된 공간에 저장되어있는 값을 할당 이후, 해제 이후 동일하게 출력해주는 코드이다.\
해당 코드의 실행 결과는 다음과 같았다.
```
a addr : 0x7ffee8cc2a30
malloc
a addr : 0x7ffee8cc2a30
a malc : 0x7fa9fac00670
a vals : 1
free
a addr : 0x7ffee8cc2a30
a malc : 0x7fa9fac00670
a vals : 1
```
결과를 보면 해제 이후에도 포인터 변수 a에 저장된 주소와, 해당 주소에 저장되어있는 값을 여전히 유지된다는것을 알 수 있었다.\
다음의 코드를 추가해 보았다.
```c
a = NULL;
printf("a free : %p\n", a);
a = malloc(2);
printf("a malc : %p\n", a);
printf("a vals : %d\n", a[0]);
```
해당 코드를 실행 하면
```
a free : 0x0
a malc : 0x7fd2b6c00670
a vals : 1
```
결과가 이렇게 나온다. 해당 코드에서 `a = NULL;` 부분을 빼고 넣고 차이점을 확인한 결과 메모리를 해제해준 이후 NULL을 넣는 이유는 할당 했던 메모리에 접근을 허용하는것과 다시 재할당 하기 전까지 해당 메모리는 사용하지 않겠다는 차이점이 있다고 생각이 들었다.\
NULL을 넣어주게되면 해당 메모리의 값을 불러올 수 없었다. 세그멘테이션 폴트가 일어나 해당 값을 읽을 수 없다. 그리고 NULL을 넣지 않았을 때, 위에 먼저 적었듯이 해당 주소와 값을 유지가 되고있었고, 또한 다시 할당을 해주었을 때, 해당 값을 출력해보면 `1`이 출력됨을 알 수 있었다.\
그리고 할당된 주소값도 변하지 않았었는데 이 것은 시스템에서 자동으로 재 할당을 해주었다고 생각이 든다.\

- free 이후 NULL 을 해주는 이유\
`free` 이후 `NULL`을 넣어주는 이유가 해당 변수의 재사용의 예상치못한 사용을 막기 위함이라 결론을 낸다.\
"`free`를 사용하는 이유가 메모리를 해제하고 그러면 다시 할당 가능한 공간으로 만들어준다." 라고만 알고 있었는데 오늘 free 함수의 작동 방식과 메모리에 값이 유지된다는것도 눈으로 다시 확인 해 볼수있었다.

### lstaddback 함수에서 인자가 이중포인터인 이유
lstaddback 함수의 인자가 이중포인터인 이유를 설명하기위해 동일한 파라미터를 가지는 lstaddfront 함수를 가지고 설명을 해보았다.\
어떠한 리스트는 
```
|content1|next| -> |content2|next| -> |content3|next| -> NULL
``` 
의 구조를 가진다고 했을 때, lstaddfront 함수를 사용해서 새로 만든 `|new|next|` 를 리스트의 제일 앞에 위치 시킨다고 하면. 새로운 리스트는 
```
|new|next| -> |content1|next| -> |content2|next| -> |content3|next| -> NULL
``` 
이러한 구조가 된다.\
이 때 lstaddfront 함수의 인자로 단일포인터 즉 제일 처음의 주소를 넣어주어도 동일한 작동을 할텐데 왜 이중포인터를 사용하는가가 질문이었다.\
제일 처음의 주소를 넣어주고 또는 제일 마지막의 주소를 인자로 주게되면 `|new|next|`의 next에 해당 인자주소를, 또는 인자의 next에 `|new|`의 주소를 넣게되면 앞과 뒤에 새로운 값을 위치시킬 수 있다. 하지만 만약 중간에 어떠한 값을 찾고 해당 값 뒤 또는 앞에 새로운 노드를 위치시킨다고 한다면, 해당 작업을 외부 함수에서 항상 반복을 해주어야 하는 불편함이 있다. 따라서 이중포인터로 리스트의 배열을 전부 넘겨주게 되면 함수에서 단일 작업으로 새로운 값을 원하는 위치에 둘 수 있기때문에 lstaddback, lstaddfront 함수에서 인자를 이중포인터로 받은것이라 생각하였다.

## 7.학습 내용에 대한 개인적인 총평
오늘의 질문 두가지 왜 split 함수에서 free를 사용하는가와 lstaddback의 인자로 왜 이중포인터를 사용하는가에 대해서 서로 생각을 나누고, 직접 실험을 해보면서 새롭게 free 함수의 작동방식과 메모리 구조에 따른 주소값의 차이도 알 수 있었다. 특히 오늘 free 함수가 메모리를 해제시켜주고 해당 변수에 다시 동적할당을 가능하게 해준는 상태로 만들어 준다는 것일뿐이라는것을 알수 있어서 정말 좋았다.\
항상 포인터의 사용법은 헷갈리는데 이렇게 같이 생각을 해보면 몰랐던 점도 알 수 있고, 코드를 작성할 때 단순히 해당 코드의 작동코드와 값 뿐만 아니라 컴퓨터가 메모리를 어떻게 사용할지를 조금이라도 주의하면서 코드를 작성하는 습관을 들이면 좋을것 같다고 느꼈다.
## 8.다음 학습 계획
- get_next_line 테스터를 통한 코드 수정
- netwhat 과제 알아보기
