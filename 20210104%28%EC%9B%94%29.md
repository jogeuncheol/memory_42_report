# 학습 레포트 6일차 2021-01-04(월)
## 1.학습 날짜
> ### 2021-01-04(월)
## 2.학습 시간
> ### 18:30 ~ 19:00 (집)
> ### 20:00 ~ 23:30 (집)
## 3.학습 범위 및 주제
### |memmove 함수의 작동 방식|
> **ft_memmove, memmove**
## 4.동료 학습 방법
- 온라인 - seshin, dongilee, hyeonpar 님과 토론
## 5.학습 목표
- memmove 함수 사용시 len 길이에 따른 에러 메시지 출력에 대해 토론하고 해결 또는 작동 방법 확인하기
## 6.상세 학습 내용
- **코딩에 사용된 시간** 약 4시간
- **참고한 내용** [메모리 오류 체크 옵션 fsanitize](https://embeddedbits.org/finding-memory-bugs-with-addresssanitizer/), [메모리 영역에 대해서](https://m.blog.naver.com/PostView.nhn?blogId=demonic3540&logNo=221202804460&proxyReferer=https:%2F%2Fwww.google.co.jp%2F), [limits 헤더와 자료형의 최대 최솟값](https://www.tutorialspoint.com/c_standard_library/limits_h.htm)

### ft_memmove 함수와 memmove 함수 작동 방법.
memmove 함수는 `src` 메모리의 내용중 `len` 만큼을 `dst` 메모리로 복사를 하는 함수이다.\
첫 질문은 `dst` 메모리 공간보다 큰 `len` byte 를 복사할 때, len가 작으면 값이 잘 출력이 되는데 100000 처럼 충분히 큰 byte를 복사한다고 하면 `bus error`가 난다는 것이었다.\

- **출력된 값은 확실한가?**
출력된 값은 정말 정상적으로 컴파일되고 출력이 된것인가? 궁금하였다.
```c
int main()
{
    char *a = malloc(1);
    char *b = "bbb";
    
    printf("a : %s\n", memmove(a, b, 3));
    printf("a : %s\n", memmove(a, b, 100000));
}
```
해당 코드로 처음부터 테스트를 진해하였고, `gcc test.c | ./a.out` 로 실행하였다.
첫 번째 출력값은 `bbb`로 출력되었고 두번째 출력은 `buserror`였다.\
하지만 코드에서 보이듯 `a`는 1byte만큼 동적할당을 해주었고, memmove 함수로 3byte만큼을 복사하도록 하였다. 이는 할당된 메모리 영역을 넘어서 다른 메모리에 값을 쓰는 행위로 출력이 되면 안된다고 생각하였다.
- **출력된 값의 진실.**\
해당 파일을 컴파일 할 때, 아무런 옵션없이 진행하였다. 그래서 메모리의 오버플로우가 발생할 경우 옵션을 통해 해당 오류의 종류와 위치를 알려주는 fsanitize 를 슬랙 검색을 통해 알수있었다.\
libft 과제를 진행하면서 알게된 옵션으로 메모리를 잘못 사용했을 때, 일반 컴파일로 나타나지 않는 오류를 꼼꼼하게 체크해 알려주는것으로 이해 하였다.\
`gcc -g -fsanitize=address test.c | ./a.out` 다시 옵션을 사용해 컴파일을 하고 실행을 하니 힙-버퍼-오버플로우 오류메시지를 볼 수 있었다.\
힙 영역은 메모리를 동적 할당한 영역이라고 이해하고있다. 가장 먼저 나타난 `a`의 메모리에서 오류가 난것을 알 수있었다.\
`a`에 할당된 메모리 크기는 1인데 3byte만큼 복사를 하겠다 하였으니 드디어 예상한 결과를 볼 수 있었다.\
- **복사인데 strcpy와 차이점은 무엇일까.**\
과제를 진행하면서 memmove도 memcpy도 strcpy와 같은 복사함수이다. 차이점은 인자로 들어오는 `len`만큼만 복사를 한다는 점이었다.\
함수를 작성하면서 생각하지 못했던 점을 오늘 질문을 통해 알게되었고, 해결 할 수 있었다.\
`memcpy`, `memccpy`, `memmove`등 메모리를 다루는 함수들은 인자로 들어온 값이 언제나 string. 문자열이 아닐수도 있다는 점을 생각하지 못하고 있었다. 이는 `bzero`, `memset` 함수를 작성할 때도 마찬가지 였다. 메모리를 다룬다는것은 그 인자가 메모리를 가리키는 것이지 해당 값에 대해 어떤 작업을 하지 않을것이라 생각이 되었다.\
실제로 strcpy 함수는 조건에 `!= '\0'`을 항상 사용하였다. string. 문자열을 다룰 때는 문자열의 끝을 체크해 복사를 해야 한다. 하지만 메모리를 다루는 복사는 메모리값을 다른 메모리로 주어진 byte 수 만큼만 복사하는것이 목적이다. 따라서 해당 함수에서는 인자로 들어온 메모리의 값에 `'\0'`, `NULL` 문자가 있는지 없는지 신경쓰지 않고, 체크할 필요도 없는것이다.
- **질문 "충분하지 못한 메모리 공간에 메모리 복사 함수를 사용한경우 byte 에 따라 출력이 다른것이 왜인가?" 의 해답.**\
fsanitize 옵션을 사용해 컴파일 해보니 memmove 함수에서 복사를 진행 할 때 버퍼 오버플로우가 발생한다는 것을 알 수 있었다. 할당된 메모리의 크기보다 크지만 그 값이 충분히 작다면 일반 컴파일에서는 오류없이 값이 출력이 되었다. 하지만 이것은 정상적으로 메모리를 사용한 것이 아니라 할당된 메모리 영역을 넘어 다른 메모리를 사용한 잘못된 메모리 사용인것을 옵션을 통해 알 수 있었고, 질문에 대한 오늘의 결론은 두 경우 모두 잘못된 메모리 사용이다. 라고 정리 하였다.

## 7.학습 내용에 대한 개인적인 총평
## 8.다음 학습 계획